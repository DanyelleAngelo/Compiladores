VAMOS CONSTRUIR UM COMPILADOR!
por Jack W. Crenshaw, Ph.D. (26/05/1990)

Copyright (C) 1990 Jack W. Crenshaw. Todos os direitos reservados.
Tradução e adaptação: Felipo Soranz (31/05/2002)

Parte 14: Tipos
---------------

No último capítulo (Parte 13: Procedimentos) eu mencionei que naquela parte e nesta também, iríamos cobrir as duas características que tendem a separar as linguagens de brinquedo das linguagens reais e usáveis. Cobrimos chamadas de procedimentos no último capítulo e desta vez vamos tratar da segunda parte.

Neste capítulo, vamos falar sobre como lidar com tipos de dados diferentes. Como eu fiz no último segmento, eu NÃO vou incorporar estas característica diretamente no compilador TINY por enquanto. Ao invés disto, vou usar a mesma abordagem que funcionou tão bem para nós no passado: usar apenas fragmentos do analisador e tokens de um só caracter. Como de costume, isto permite que tratemos diretamente do núcleo do problema, sem ter que nos preocuparmos em arrumar código desnecessário. Já que a maioria dos problemas em tratar de tipos múltiplos ocorrem em operações aritméticas, é aí que iremos concentrar nosso foco.

Algumas palavras de aviso: Primeiro, há alguns tipos que eu NÃO vou cobrir neste capítulo. Aqui, nós vamos APENAS falar dos tipos simples e pré-definidos. Não vamos tratar nem sequer de vetores, ponteiros ou sequencias; mas talvez tratemos deles mais adiante.

Segundo, também não vamos discutir tipos definidos pelo usuário. Isto não virá a acontecer até muito mais tarde, pela simples razão de eu não estar convencido de que tipos definidos pelo usuário pertecem a uma linguagem que denominamos KISS. Em capítulos futuros, eu pretendo cobrir pelo menos os conceitos gerais de tipos definidos pelo usuário, registros, etc., apenas para que a série esteja completa. Mas se eles vão entrar ou não na linguagem KISS ainda é uma questão em aberto.

Finalmente, eu devo avisá-lo: o que estamos a ponto de fazer PODE adicionar complicação extra tanto ao analisador quanto ao gerador de código. Tratar de variáveis de tipos diferentes não é tão complicado assim, a complexidade aparece quando você adiciona as regras para a conversão entre tipos. Em geral, você pode tornar o compilador tão simples ou tão complexo quanto quiser, dependendo da maneira como você define as regras de conversão de tipo. Mesmo que você decida não permitir qualquer tipo de conversão (como em Ada, por exemplo) o problema ainda permanece, e o problema está na matemárica. Quando você multiplica dois números curtos, por exemplo, você pode obter resultados longos.

Eu tentei abordar este problema com muito cuidados, em uma tentativa de mantê-lo simples. Mas não é possível evitar a complexidade por completo. Como tem acontecido com frequência, acabamos tendo que escolher entre manter a qualidade de código e evitar a complexidade, e como de costume eu procuro optar pela abordagem mais simples.

O Que Vem Em Seguida?
---------------------

Antes de nos aprofundarmos no tutorial, eu acho que você gostaria de saber para onde estamos indo... especialmente depois de tanto tempo após o último capítulo.

Eu não estive ocioso neste meio-tempo. O que eu tenho feito é reorganizar o compilador em si em módulos separados. Um dos problemas que eu encontrei é que conforme cobrimos novas áreas e adicionamos novas características a TINY, ele se torna cada vez maior. Eu percebi alguns capítulos atrás que isto estava causando problemas, e é por isso que eu voltei a usar apenas fragmentos do compilador no capítulo anterior e neste também. O problema é que simplesmente parece inútil ter que reproduzir o código para, digamos, processamento booleano de Ou-exclusivo, quando nosso assunto é passagem de parâmetros.

A maneira óbvia de tratar do problema é separar o compilador em módulos compiláveis separadamente. Desta forma podemos esconder código realmente complexo (como a analise aritmética e booleana completa) em uma única unidade, e simplesmente anexá-lo sempre que necessário. Desta forma, o único código que terei que reproduzir nestes capítulos será o código diretamente relacionado à discussão.

Em todo caso, a idéia nos próximos capítulos da série, é apresentar um conjunto completo de módulos, e compiladores funcionais completos também. O plano, de fato, é ter TRÊS compiladores: Um para a versão de um caracter de TINY (para usar nas experiências), um para TINY completo, e outro para KISS. Neste ponto eu isolei as diferenças entre TINY e KISS, que são as seguintes:

	- TINY terá suporte a apenas dois tipos de dados: o caracter e o inteiro de 16-bits. Eu posso tentar fazer algo com strings também, já que sem elas um compilador não seria de grande utilidade. KISS vai suportar todos os tipos simples usuais, incluindo vetores e até mesmo números de ponto flutuante.
	
	- TINY só terá duas construções de controle, o IF e o WHILE. KISS vai suportar um conjunto bem mais rico de construções, incluindo uma que não discutimos ainda... o comando CASE.
	
	- KISS terá suporte a módulos compilados separadamente.

Um aviso: os módulos vão continuar sendo escritos para suportar Assembly para processadores 80x86, usando modelamento real de memória e 16-bits. Porém, em todos os programas a geração do código será devidamente encapsulada em uma única unidade, para que qualquer estudante aplicado possa facilmente portar a saída para o processador ou sintaxe que preferir. Esta tarefa é deixada como um "exercício para o estudante".

Mas chega de falação. Vamos começar com o estudo de tipos. Como eu disse anteriormente, vamos tratar disto da mesma forma que no capítulo anterior: fazendo pequenos experimentos usando tokens de um só caracter.

A Tabela de Símbolos
--------------------

Deve parecer evidente que, se vams tratar de variáveis de tipos diferentes, vamos ter que armazenar que tipos são estes. O lugar ideal para isto obviamente é a tabela de símbolos, e nós já a usamos para fazer a distinção, por exemplo, entre variáveis locais e globais, e entre variáveis e procedimentos.

A estrutura para a tabela de símbolos para tokens de um só caracter é particularmente simples, e nós já fizemos uso dela diversas vezes antes. Para tratar dela, vamos emprestar algumas rotinas que já usamos antes.

Primeiro, temos que declarar a tabela de símbolos em si:

#define SYMTBL_SZ 26
char symtbl[SYMTBL_SZ]; /* tabela de símbolos */

Em seguida, temos que nos certificar de que ela foi inicializada na rotina "init":

/* inicialização do compilador */
void init()
{
        int i;

        for (i = 0; i < SYMTBL_SZ; i++)
                symtbl[i] = '?';

        nextchar();
}

Nós realmente não precisamos da próxima rotinas, mas ela será útil para depuração. Tudo o que ela faz é exibir todo o conteúdo da tabela de símbolos:

/* exibe a tabela de símbolos */
void dumptable()
{
        int i;

	printf("Symbol table dump:\n");

        for (i = 0; i < SYMTBL_SZ; i++)
                printf("%c = %c\n", i + 'A', symtbl[i]);
}

Realmente não importa muito onde você coloca esta rotina... eu pretendo colocar todas as rotinas da tabela de símbolo juntas.

Se você é o tipo cuidadoso (como eu sou), vai preferir começar com um programa de teste que não faz nada a não ser inicializar, e em seguida exibir a tabela. Apenas para ter certeza de que estamos sintonizados, vou reproduzir o programa completo abaixo, com as novas rotinas. Repare que esta versão tem suporte a espaços em branco:

/*
Tipos de variáveis

O código abaixo foi escrito por Felipo Soranz e é uma adaptação
do código original em Pascal escrito por Jack E. Crenshaw em sua
série "Let's Build a Compiler".

Este código é de livre distribuição e uso.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SYMTBL_SZ 26
char symtbl[SYMTBL_SZ]; /* tabela de símbolos */

char look; /* O caracter lido "antecipadamente" (lookahead) */

/* protótipos */
void init();
void nextchar();
void error(char *s);
void fatal(char *s);
void expected(char *s);
void dumptable();
int isaddop(char c);
int ismulop(char c);
int isorop(char c);
int isrelop(char c);
void skipwhite();
void newline();
void match(char c);
char getname();
char getnum();

/* PROGRAMA PRINCIPAL */
int main()
{
	init();
        dumptable();

	return 0;
}

/* inicialização do compilador */
void init()
{
        int i;

        for (i = 0; i < SYMTBL_SZ; i++)
                symtbl[i] = '?';

        nextchar();
        skipwhite();
}

/* lê próximo caracter da entrada em lookahead */
void nextchar()
{
	look = getchar();
}

/* imprime mensagem de erro sem sair */
void error(char *s)
{
	fprintf(stderr, "Error: %s\n", s);
}

/* imprime mensagem de erro e sai */
void fatal(char *s)
{
	error(s);
	exit(1);
}

/* mensagem de erro para string esperada */
void expected(char *s)
{
	fprintf(stderr, "Error: %s expected\n", s);
	exit(1);
}

/* exibe a tabela de símbolos */
void dumptable()
{
        int i;

	printf("Symbol table dump:\n");

        for (i = 0; i < SYMTBL_SZ; i++)
                printf("%c = %c\n", i + 'A', symtbl[i]);
}

/* testa operadores de adição */
int isaddop(char c)
{
	return (c == '+' || c == '-');
}

/* testa operadores de multiplicação */
int ismulop(char c)
{
	return (c == '*' || c == '/');
}

/* testa operadores OU */
int isorop(char c)
{
	return (c == '|' || c == '~');
}

/* testa operadores relacionais */
int isrelop(char c)
{
	return (strchr("=#<>", c) != NULL);
}

/* pula caracteres em branco */
void skipwhite()
{
	while (look == ' ' || look == '\t')
		nextchar();
}

/* reconhece uma quebra de linha */
void newline()
{
        if (look == '\n')
                nextchar();
}

/* verifica se look combina com caracter esperado */
void match(char c)
{
	char s[2];

	if (look == c)
		nextchar();
	else {
		s[0] = c; /* uma conversao rápida (e feia) */
		s[1] = '\0'; /* de um caracter em string */
		expected(s);
	}
        skipwhite();
}

/* analisa e traduz um nome (identificador ou palavra-chave) */
char getname()
{
	char name;

	if (!isalpha(look))
		expected("Name");
	name = toupper(look);
	nextchar();
        skipwhite();

	return name;
}

/* analisa e traduz um número inteiro */
char getnum()
{
	char num;

	if (!isdigit(look))
		expected("Integer");
	num = look;
	nextchar();
        skipwhite();

        return num;
}

OK, execute este programa. Você deve obter como saída todas as letras do alfabeto (potenciais identificadores), cada um seguido por um sinal de interrogação. Nada muito excitante, mas é um começo.

É claro, em geral nós só queremos ver os tipos das variáveis que já foram definidas. Podemos eliminar as outras inserindo uma condição em "dumptable". Altere o laço FOR para que fique:

        for (i = 0; i < SYMTBL_SZ; i++)
        	if (symtbl[i] != '?')
                	printf("%c = %c\n", i + 'A', symtbl[i]);
                	
Agora, execute o programa novamente. O que aconteceu?

Bem, isto é mais chato que antes até! Não houve qualquer saída, já que neste ponto nenhum dos nomes foi declarado. Podemos melhorar as coisas inserindo alguns comandos para declarar algumas entradas no programa principal. Tente algo assim:

	symtbl[0] = 'a';
	symtbl[5] = 'p';
	symtbl[10] = 'x';
	
Desta vez, quando você executar o programa, você deve obter uma saída mostrando a tabela de símbolos funcionando corretamente.

Adicionando Entradas
--------------------


É claro que escrever diretamente na tabela é uma prática muito pobre, e não é algo que vai nos ajudar muito depois. Ao mesmo tempo, sabemos que vamos precisar testar a tabela, para ter certeza que não estamos redeclarando uma variável que já está em uso (fácil de fazer com apenas 26 opções!). Para tratar disto tudo, entre com as seguintes novas rotinas:

/* retorna o tipo de um identificador */
char symtype(char name)
{
        return symtbl[name - 'A'];
}

/* verifica se "name" consta na tabela de símbolos */
char intable(char name)
{
        return (symtbl[name - 'A'] != '?');
}

/* avisa a respeito de um identificador desconhecido */
void duplicated(char name)
{
	fprintf(stderr, "Error: Duplicated identifier %c\n", name);
	exit(1);
}

/* verifica se um identificador já foi declarado */
void checkdup(char name)
{
        if (intable(name))
                duplicated(name);
}

/* adiciona novo identificador à tabela de símbolos */
void addsymbol(char name, char type)
{
	checkdup(name);
        symtbl[name - 'A'] = type;
}

Agora altere as três linhas no programa principal para:

	addsymbol('A', 'a');
	addsymbol('F', 'p');
	addsymbol('K', 'x');

e execute o programa novamente. Funcionou? Então temos as rotinas da tabela de símbolos necessárias para suportar nosso trabalho com tipos. Na próxima seção, vamos começar a usá-las.

Alocando Espaço de Armazenamento
--------------------------------

Em outros programas como este, incluindo o compilador TINY em si, já tratamos do problema de declarar variáveis globais, e o código gerado para elas. Vamos construir uma versão simplificada de um "compilador" aqui, cuja única função é permitir que declaremos variáveis. Lembre-se, a sintaxe para uma declaração é:

	<data decl> ::= VAR <identifier>
	
Novamente, podemos emprestar a maior parte do código dos programas anteriores. O que segue é uma versão simplificada das versões anteriores destas rotinas. Elas estão muito simplificadas já que eu eliminei coisas como listas de variáveis e inicializadores. Na rotina "allocvar", repare que a chamada a "addsymbol" também vai cuidar de verificar declarações duplicadas:

/* avisa a respeito de uma palavra-chave desconhecida */
void unrecognized(char name)
{
        fprintf(stderr, "Error: Unrecognized keyword %c\n", name);
        exit(1);
}

/* aloca espaço de armazenamento para variável */
void asm_allocvar(char name)
{
        addsymbol(name, 'v');
        printf("%c: dw 0\n", name);
}

/* analiza e traduz a declaração de uma variável */
void decl()
{
        match('v');
        asm_allocvar(getname());
}

/* analiza e traduz as declarações globais */
void topdecls()
{
        while (look != '.') {
                switch (look) {
                  case 'v':
                        decl();
                        break;
                  default:
                        unrecognized(look);
                        break;
                }
                newline();
        }
}

Agora, no programa principal, adicione uma chamada a "topdecls" e execute o programa. Tente alocar algumas variáveis, e repare o código sendo gerado. Isto é algo velho e conhecido pra você, portanto o resultado deve ser familiar. Repare no código de "topdecls". O programa é terminado por um ponto (".").

Enquanto estiver testanto, tente declarar duas variáveis com o mesmo nome, e verifique que o analisador avisa a respeito do erro.

Declarando Tipos
----------------

Alocar armazenamento de tamanhos diferentes é simples como modificar o procedimento "topdecls" para reconhecer mais de uma palavra-chave. Há um certo número de decisões a serem tomadas aqui, em termos de como a sintaxe deve ser, etc., mas por enquanto eu vou deixar de lado todos os problemas e simplesmente declarar que a nossa sintaxe será:

	<data decl> ::= <typename> <identifier>
	
onde:

	<typename> ::= BYTE | WORD | LONG
	
Podemos criar o código para tratar destas modificações com alterações simples. Nas rotinas abaixo, repare que eu separei a parte de geração de código de "asm_allocvar" e "alloc". Isto vai manter nosso desejo de encapsular o código dependente de máquina do compilador.

/* gera código para armazenamento de variável */
void asm_allocvar(char name, char type)
{
        int btype; /* tamanho em bytes */

        switch (type) {
          case 'b':
          case 'w':
                btype = type;
                break;
          case 'l':
                btype = 'd';
                break;
        }
        printf("%c d%c 0\n", name, btype);
}

/* aloca espaço de armazenamento para variável */
void alloc(char name, char type)
{
        addsymbol(name, type);
        asm_allocvar(name, type);
}

/* analiza e traduz a declaração de uma variável */
void decl()
{
        char type = look;
        nextchar();
        alloc(getname(), type);
}

/* analiza e traduz as declarações globais */
void topdecls()
{
        while (look != '.') {
                switch (look) {
                  case 'b':
                  case 'w':
                  case 'l':
                        decl();
                        break;
                  default:
                        unrecognized(look);
                        break;
                }
                newline();
        }
}

Faça as mudanças nestas rotinas, e faça um teste. Use os caracteres "b", "w" e "l" no lugar das palavras-chave (eles devem estar em letras minúsculas por enquanto). Você verá que em cada caso, estamos armazenando o tamanho de armazenamento apropriado. Repare através da tabela de símbolos exibida que os tamanhos (tipos) estão armazenados para uso posterior. Que uso posterior? Bem, este é o assunto do resto deste capítulo.

Atribuições
-----------

Agora que podemos declarar variáveis de tipos e tamanhos diferentes, chegamos ao momento em que deveríamos fazer algo de útil com elas. Pra começar, vamos apenas tentar carregá-las no registrador primário (AX no nosso caso). Faz sentido usar a mesma idéia de "alloc", isto é, fazer uma rotina de carregamento capaz de ler tamanhos diferentes. Também gostaríamos de manter o código dependente de máquina isolado. A rotina de carregamento é algo assim:

/* gera código para carregar variável de acordo com o tipo */
void asm_loadvar(char name, char type)
{
	switch (type) {
	  case 'b':
	  	printf("\tmov al, %c\n", name);
	  	break;
	  case 'w':
	  	printf("\tmov ax, %c\n", name);
	  	break;
	  case 'l':
  		printf("\tmov dx, word ptr [%c+2]\n", name);
  		printf("\tmov ax, word ptr [%c]\n", name);
	}
}

(Repare que como estamos usando apenas registradores de 16-bits, precisamos usar um par de registradores para representar números de 32-bits, como os números do tipo "long". No caso, estou usando o par DX:AX, pois é o padrão, no caso de assembly 80x86 16-bits. Se usássemos os registradores de 32-bits, seria possível usar um só registrador, no caso EAX, para representar os números. Isto é relativamente fácil de modificar e é deixado como um "exercício para o estudante".)

Antes de mais nada, precisamos ter certeza de que o tipo com o qual estamos lidando é um tipo carregável. Isto parece ser o trabalho de mais um reconhecedor:

/* reconhece um tipo de variável válido */
int isvartype(char c)
{
	return (c == 'b' || c == 'w' || c == 'l');
}

Em seguida, seria bom ter uma rotina que captura o tipo de uma variável da tabela ao mesmo tempo que verifica se o tipo é válido:

/* avisa a respeito de um identificador que não é variável */
void notvar(char name)
{
	fprintf(stderr, "Error: %c is not a variable\n", name);
	exit(1);
}

/* pega o tipo da variável da tabela de símbolos */
char vartype(char name)
{
	char type;
	
	type = symtype(name);
	if (!isvartype(type))
		notvar(name);

	return type;
}

Armado com estas ferramentar, o procedimento para efetuar o carregamento destas variáveis é trivial:

/* carrega variável */
void loadvar(char name)
{
        asm_loadvar(name, vartype(name));
}

(Nota: Eu sei que isto tudo é um tanto ineficiente. Em um programa de produção, provavelmente faríamos algo para evitar ter de aninhar tantas chamadas de procedimento assim. Não se preocupe com isto. Isto é um EXECÍCIO, lembra-se? É mais importante fazer a coisa certa e entendê-la, ao invés de obter a resposta errada, rapidamente. Se o compilador já estiver completo e você estiver infeliz com seu desempenho, sinta-se livre para voltar e otimizá-lo!)

Seria uma boa idéia testar o programa a esta altura. Como ainda não temos um procedimento para tratar de atribuições ainda, simplesmente adicionamos as linhas:

	loadvar('A');
	loadvar('B');
	loadvar('C');
	loadvar('X');

ao programa principal. Portanto, depois da seção de declarações terminar, será gerado código para os carregamentos. Você pode fazer diversos testes com isto, e tentar diferentes combinações de declarações para A, B, C e X e ver como erros são tratados.

Tenho certeza que você não ficaria surpreso em saber que o código para armazenar variáveis é muito parecido com aquele para carregá-las. Os procedimentos necessários são mostrados a seguir:

/* gera código para armazenar variável de acordo com o tipo */
void asm_storevar(char name, char type)
{
	switch (type) {
	  case 'b':
	  	printf("\tmov %c, al\n", name);
	  	break;
	  case 'w':
	  	printf("\tmov %c, ax\n", name);
	  	break;
	  case 'l':
  		printf("\tmov word ptr [%c+2], dx\n", name);
  		printf("\tmov word ptr [%c], ax\n", name);
	}
}

/* armazena variável */
void storevar(char name)
{
        asm_storevar(name, vartype(name));
}

Você pode testar isto da mesma forma que os carregamentos.

Agora, é claro, que é um passo relativamente pequeno usar isto para tratar comandos de atribuição. O que vamos fazer é criar uma versão especial do procedimento "block" para suportar apenas comandos de atribuição, e também uma versão simplificada de "expression" que suporta apenas variáveis simples como expressões válidas. Aqui estão:

/* analisa e traduz uma expressão */
void expression()
{
	loadvar(getname());
}

/* analisa e traduz uma atribuição */
void assignment()
{
	char name;
	
	name = getname();
	match('=');
	expression();
	storevar(name);
}

/* analisa traduz um bloco de comandos */
void block()
{
	while (look != '.') {
		assignment();
		newline();
	}
}

(Vale a pena notar que as novas rotinas que nos permitem manipular tipos são mais simples até do que já fizemos antes. Isto acontesse graças à encapsulação da geração de código dos procedimentos.)

Há um pequeno problema. Antes, usávamos o ponto final para sair da rotina "topdecls". Agora este é o caracter errado... ele é usado para terminar "block". Em programas anteriores, usamos o símbolo BEGIN (abreviado como "b") para sair. Mas agora ele está sendo usado como um símbolo para tipo.

Há uma solução, que não é das melhores, mas que é simples de fazer. Vamos usar um "B" MAIÚSCULO para representar BEGIN. Então, troque o caracter no laço de "topdecls", de "." para "B" e tudo estará bem. Agora, podemos alterar o programa principal para que fique:

/* PROGRAMA PRINCIPAL */
int main()
{
	init();
        topdecls();
	match('B');
	newline();
	block();
        dumptable();

	return 0;
}

(Agora repare que eu precisei espalhar algumas chamadas a "newline" para tratar da questão da quebra de linha.)

Certo, execute o programa. Tente esta entrada:

	ba        { byte a }   *** NÃO DIGITE OS COMENTÁRIOS!!! ***
	wb        { word b }
	lc        { long c }
	B         { begin  }
	a=a
	a=b
	a=c
	b=a
	b=b
	b=c
	c=a
	c=b
	c=c
	.

Para cada declaração, você deve obter o código gerado para o espaço alocado de armazenamento. Para cada atribuição, você deve obter o código para carregar as variáveis com o tamanho correto, e armazená-las, também com o tamanho correto.

Só há um pequeno problea: O código gerado está ERRADO!

Obserce o código para "a=c" acima. O código é:

	mov dx, word ptr [C+2]
	mov ax, word ptr [C]
	mov A, al

Este código está correto. Ele vai fazer com que o 8 bits menos significantes de C sejam armazenados em A, o que é um comportamento razoável. É basicamente o que se espera que aconteça.

Mas agora, observe o caso oposto. Para "c=a", o código gerado é:

	mov al, A
	mov word ptr [C+2], dx
	mov word ptr [C], ax
	
Isto NÃO está correto. Ele vai fazer com que o byte armazenado em A, seja armazenado no registrador AL, que corresponde aos 8-bits inferiores de AX. De acordo com as regras para o processador 80x86, os 8-bits superiores (registrador AH) não são modificados, e muito menos o valor de DX, que seriam os 16-bits mais significativos do nosso valor de 32-bits. Isto significa que quando armazenamos o valor inteiro de 32-bits em C, qualquer valor que tenha ficado anteriormente em AH e DX será armazenado também. Nada bom.

Esta questão com o qual nos defrontamos anteriormente é o problema de CONVERSÃO DE TIPO, ou COERÇÃO.

Antes de fazer qualquer outra coisa com variáveis de tipos diferentes, mesmo que seja só copiá-los, temos que tratar deste problema. Não é a parte mais simples do compilador. A maior parte dos bugs que eu já vi em compiladores de produção tem a ver com erros em conversão de tipos para certas combinações obscuras de argumentos. Como de costume, há uma troca entre complexidade do compilador e a qualidade potencial do código gerado. Vamos continuar tomando o caminho que leva à simplicidade do compilador.

A Saída dos Covardes
--------------------

Antes de nos afundarmos em detalhes (e complexidade em potencial) de conversão de tipos, eu gostaria de lhe mostrar que há uma maneira extremamente simples de resolver o problema: simplesmente converta toda variável para um inteiro longo quando carregá-la!

Isto requer a inserção de poucas linhas a "asm_loadvar", cujo trabalho é zerar o(s) registrador(es) envolvido(s) para que o valor resultante seja válido em qualquer tipo. Aqui está a versão modificada:

/* gera código para carregar variável de acordo com o tipo */
void asm_loadvar(char name, char type)
{
	switch (type) {
	  case 'b':
	  	printf("\txor dx, dx\n");
	  	printf("\txor ax, ax\n");
	  	printf("\tmov al, %c\n", name);
	  	break;
	  case 'w':
	  	printf("\txor dx, dx\n");
	  	printf("\tmov ax, %c\n", name);
	  	break;
	  case 'l':
  		printf("\tmov dx, word ptr [%c+2]\n", name);
  		printf("\tmov ax, word ptr [%c]\n", name);
	}
}

(Repare que "asm_storevar" não precisa de mudança similar.)

Se você fizer alguns testes com a nova versão, vai descobrir que tudo funciona corretamente, apesar de um pouco ineficiente às vezes. Por exemplo, considere o caso "a=b" (para as mesmas declarações acima). Agora o código gerado é:

	xor dx, dx
	mov ax, B
	mov A, al

Neste caso, ocorre que é desnecessário limpar o valor dos registradores, já que o resultado está sendo armazenado numa variável do tipo byte. Com um pouco de trabalho é possível fazer melhor. No entanto, isto não é tão ruim, e é o tipo de ineficiência típica que já vimos em compiladores simplificados.

Eu devo avisar que, alterando os bits superiores para zero, estamos de fato tratando os números como inteiros SEM SINAL. Se queremos tratar deles com sinal (o caso mais comum) devemos fazer uma extensão de sinal após o carregamento, ao invés de zerar o valor antes. Isto é feito através de CBW (Convert Byte to Word) e CWD (Convert Word to Dword). Para encerrar esta parte da discussão, vamos alterar "asm_loadvar":

/* gera código para carregar variável de acordo com o tipo */
void asm_loadvar(char name, char type)
{
	switch (type) {
	  case 'b':
	  	printf("\tmov al, %c\n", name);
	  	printf("\tcbw\n");
	  	printf("\tcwd\n");
	  	break;
	  case 'w':
	  	printf("\tmov ax, %c\n", name);
	  	printf("\tcwd\n");
	  	break;
	  case 'l':
  		printf("\tmov dx, word ptr [%c+2]\n", name);
  		printf("\tmov ax, word ptr [%c]\n", name);
	}
}

(Use CWDE para converter AX em EAX se estiver usando registradores de 32 bits.)

Para tratar de um byte como sendo sem sinal (como em Pascal e C) e de um word com sinal, basta remover a conversão de byte para word (CBW) após o carregamento e zerar AX antes:

	  case 'b':
	  	printf("\txor ax, ax\n");
	  	printf("\tmov al, %c\n", name);
	  	printf("\tcwd\n");
	  	break;

Uma Solução Mais Razoável
-------------------------

Como já vimos, promover toda variável a um número longo resolve o problema, mas dificilmente pode ser considerado eficiente, e provavelmente não seria aceitável mesmo para aqueles de nós que julgam não se importarem com a eficiência. Significa que todas as operações aritméticas serão feitas com precisão de 32-bits, o que vai DUPLICAR o tempo de execução da maioria das operações, e fazer algo até pior na multiplicação e divisão. Para estas operações, precisaríamos chamar sub-rotinas para fazer o cálculo, mesmo se os dados fossem do tipo byte ou word. A coisa toda não parece muito boa, pois ignora os problemas reais.

Certo, portanto esta solução não é muito boa. Haveria uma forma relativamente fácil de obter conversão de dados? Podemos continuar Mantendo a Coisa Simples?

Sim, de fato. Tudo o que devemos fazer é colocar a conversão na outra ponto... isto é, convertemos os valores quando eles serão armazenados, ao invés de quando são carregados.

Mas lembre-se, a parte do armazenamento de uma atribuição é de certa forma independente do carregamento dos dados, que é tratado pelo procedimento "expression". Em geral, a expressão pode ser arbitrariamente complexa. Como a rotina "assignment" pode saber que tipo de dado foi deixado nos registradores?

Novamente, a resposta é simples: Nós simplesmente PERGUNTAMOS à rotina "expression"! A resposta é retornada pela função.

Tudo isto requer que diversas rotinas sejam modificadas, mas as modificações, como o próprio método, são simples. Primeiramente, já que não vamos pedir para que "asm_loadvar" faça a conversão, retornemos à versão mais simples:

/* gera código para carregar variável de acordo com o tipo */
void asm_loadvar(char name, char type)
{
	switch (type) {
	  case 'b':
	  	printf("\tmov al, %c\n", name);
	  	break;
	  case 'w':
	  	printf("\tmov ax, %c\n", name);
	  	break;
	  case 'l':
  		printf("\tmov dx, word ptr [%c+2]\n", name);
  		printf("\tmov ax, word ptr [%c]\n", name);
	}
}

Em seguida, vamos adicionar uma nova rotina que converte de tipo para outro:

/* converte tipo origem para destino */

void asm_convert(char src, char dst)
{
	if (src == dst)
		return;
	
	if (src == 'b')
		printf("\tcbw\n");
	if (dst == 'l')
		printf("\tcwd\n");
}

Esta versão da conversão considera todos os tipos como sendo com sinal. Se fossemos considerar "byte" sem sinal, basta trocar "cbw", que faz a extensão de sinal de "byte" para "word", por "xor ah, ah", que zera os bits mais significativos de AX.

Em seguida, temos que fazer a lógica necessária para carregar e armazenar uma variável de qualquer tipo. Aqui estão as rotinas:

/* carrega variável */
char loadvar(char name)
{
	char type = vartype(name);

        asm_loadvar(name, type);

        return type;
}

/* armazena variável */
void storevar(char name, char srctype)
{
	char vartype = vartype(name);
	asm_convert(srctype, vartype);
        asm_storevar(name, vartype);
}

Note que "loadvar" é uma função, que não só emite código para o carregamento, mas também retorna o tipo da variável. Desta forma, sempre sabemos com que tipo de dados estamos tratando. Quando executarmos "storevar", passamos o tipo corrente do valor em AX (ou DX:AX). Já que "storevar" sabe o tipo da variável de destino, ele pode converter conforme necessário.

Armado com estas novas rotinas, a implementação de nosso comando de atribuição rudimentar é essencialmente trivial. O procedimento "expression" agora se torna uma função, que retorna seu tipo para o procedimento "assignment":

/* analisa e traduz uma expressão */
char expression()
{
	return loadvar(getname());
}

/* analisa e traduz uma atribuição */
void assignment()
{
	char name, type;
	
	name = getname();
	match('=');
        type = expression();
	storevar(name, type);
}

Novamente, repare como são incrívelmente simples estas duas rotinas. Encapsulamos toda a lógica de tipos em "loadvar" e "storevar", e o truque de passar o tipo torna o resto do trabalho extremamente fácil. É claro, tudo isto é para o nosso caso especial e trivial de "expression". Naturalmente, para o caso geral isto será mais complexo. Mas você está olhando agora para a versão FINAL de "assignment"!

Tudo isto parece ser uma solução muito simples e limpa, e realmente é. Compile esta versão do probrama e e faça os mesmos testes de antes. Você verá que todos os tipos de dados serão convertidos apropriadamente, e há poucas (ou nenhuma) instrução desperdiçada.

Apesar de não termos considerado variáveis sem sinal neste caso, eu acho que seria fácil arrumar o procedimento "asm_convert" para tratar destes casos também. Isto fica como um "exercício para o estudante".

Argumentos Literais
-------------------

Leitores atentos devem ter reparado, que nós sequer temos uma forma apropriada de um fator simples ainda, pois não permitimos o carregamento de constantes literais, apenas variáveis. Vamos arrumar isto agora.

Para começar, vamos precisar de uma função "getnum". Até agora vimos diversas versões desta versão, algumas retornando apenas um caracter, outras uma string, e outras um valor inteiro. A que vamos usar aqui vai retornar um inteiro longo, para que ela possa tratar qualquer coisa que usarmos. Repare que nenhuma informação de tipo é retornada aqui: "getnum" não se importa em como o número será usado:

/* analisa e traduz um número inteiro longo */
long getnum()
{
	long val;
	
	if (!isdigit(look))
		expected("Integer");
	val = 0;
	while (isdigit(look)) {
		val *= 10;
		val += look - '0';
		nextchar();
	}
	skipwhite();
	return val;
}

Agora, quando tratarmos de dados literais, temos um pequeno problema. Com variáveis, sabemos que tipo as coisas devem ter, pois elas foram declaradas para ser daquele tipo. Não possuímos este tipo de informação para literais. Quando o programador diz "-1" isto significa um valor "byte", "word" ou "long"? Não temos nenhuma pista. A coisa mais óbvia a fazer seria usar a maior versão possível, isto é, "long". Mas esta é uma má idéia, pois quando estivermos tratando de expressões mais complexas, isto vai fazer com que toda expressão envolvendo literais seja promovida para "long" também.

Uma abordagem melhor é selecionar o tipo baseado no valor do literal, conforme o seguinte:

/* carrega uma constante no registrador primária */
char loadnum(long val)
{
	char type;
	
	if (val >= -128 && val <= 127)
		type = 'b';
	else if (val >= -32768 && val <= 32767)
		type = 'w';
	else
		type = 'l';
	asm_loadconst(val, type);

	return type;
}

Repare que "loadnum" chama a nova da rotina geradora de código "loadconst", que tem um argumento adicional para definir o tipo:

void asm_loadconst(long val, char type)
{
	switch (type) {
	  case 'b':
		printf("\tmov al, %d\n", (int) val);
	  	break;
	  case 'w':
		printf("\tmov ax, %d\n", (int) val);
	  	break;
	  case 'l':
		printf("\tmov dx, %u\n", val >> 16);
		printf("\tmov ax, %u\n", val & 0xFFFF);
	  	break;
	}
}

(Repare que para o caso de uma constante "long", não há como carregá-la diretamente em DX e AX. Por isso foi preciso carregar os registradores separademente, colocando em DX os 16 bits mais significativos e em AX os 16 menos significativos. Isto não é necessário se você estiver usando o registrador EAX de 32-bits ao invés do para DX:AX de registradores de 16-bits)

Agora podemos modificar "expression" para acomodar os dois tipos de fatores possíveis:

/* analisa e traduz uma expressão */
char expression()
{
	char type;
	
	if (isalpha(look))
		type = loadvar(getname());
	else
		type = loadnum(getnum());
	
	return type;
}

(Certamente isto não machucou muito, apenas algumas linhas extra pra fazer o trabalho.)

Certo, compile este código no seu programa e faça um teste. Você vai constatar que ele funciona para qualquer expressão com variáveis ou constantes válidas.

Expressões com Soma
-------------------

Se você tem acompanhado esta série deste o início, eu tenho certeza que você sabe o que vem em seguida: vamos expandir a expressão para tratar primeiro de expressões com soma e subtração, então multiplicação e em seguida expressões gerais com parênteses.

A parte boa é que já temos um padrão para tratar destas expressões mais complexas. Tudo o que temos que fazer é ter certeza que todos os procedimentos chamados por "expression" ("term", "factor", etc.) sempre retornem um identificador de tipo. Se fizermos desta forma, dificilmente será preciso alterar a estrutura do programa.

A primeira parte é fácil: podemos renomear nossa função existente para "term", como já fizemos tantes vezes antes, e criar uma nova versão para "expression":

/* analisa e traduz uma expressão */
char expression()
{
	char type;

	if (isaddop(look))
		type = unop();
	else
		type = term();
	while (isaddop(look)) {
		asm_push(type);
		switch (look) {
		  case '+':
		  	type = add(type);
		  	break;
		  case '-':
		  	type = subtract(type);
		  	break;
		}
	}

	return type;
}

Note nesta rotina como cada chamada a procedimento se transformou numa chamada de função, e como a variável local "type" é atualizada a cada passagem.

Repare também na nova chamada à função "unop", que trata dos operadores unários de sinal. Esta mudança não é necessária... poderíamos manter uma forma como a usada anteriormente. Eu decidi introduzir "unop" como uma rotina separada pois torna as coisas mais fáceis, mais tarde, ao produzir um código melhor do que o que estamos produzindo. Em outras palavras, estou prestando atenção nos detalhes de otimização.

Para esta versão, porém, vou manter o mesmo código bobo que faz com que a rotina seja trivial:

char unop()
{
	asm_clear();
	return 'w';
}

O procedimento "asm_push" é uma rotina de geração de código, e agora possui um argumento de tipo:

/* coloca valor na pilha */
void asm_push(char type)
{
	if (type == 'b')
		printf("\tcbw\n"); /* só é possível empilhar "word"s */
	if (type == 'l')
		printf("\tpush dx\n");
	printf("\tpush ax\n");
}

Agora vamos dar uma olhada nas funções "add" e "subtract". Nas versões anteriores destas rotinas, fizemos com que elas chamassem as rotinas de geração de código "asm_popadd" e "asm_popsub". Vamos continuar fazendo assim, o que torna as funções em si extremamente simples:

/* reconhece e traduz uma soma */
char add(char type)
{
	match('+');
	return asm_popadd(type, term());
}

/* reconhece e traduz uma subtração */
char subtract(char type)
{
	match('-');
	return asm_popsub(type, term());
}

A simplicidade chega a ser decepcionante, pois o que fizemos foi delegar a lógica para "asm_popadd" e "asm_popsub", que não são somente rotinas de geração de código. Elas devem também tomar conta da conversão de tipos necessária.

E que conversão é esta? Simples: ambos argumentos devem ter o mesmo tamanho e o resultado também possui este tamanho. O menor dos argumentos deve ser "promovido" para o tamanho do maior.

Mas isto apresenta um certo problema. Se o argumento a ser promovido é o segundo (isto é, o que está no registrador primário), está tudo bem. Caso contrário, temos um problema: não podemos mudar o tamanho da informação que já está na pilha.

A alternativa é introduzir uma rotina "asm_pop" análoga a "asm_push". Mas esta rotina deve armazenar o valor no registrador secundário (BX ou CX:BX para "long").

/* coloca em registrador(es) secundário(s) valor da pilha */
void asm_pop(char type)
{
        printf("\tpop bx\n");
        if (type == 'l')
                printf("\tpop cx\n");
}

A idéia geral é que todas as rotinas "asm_pop??" usem esta rotina para obter o primeiro operando. Quando isto é feito, teremos os dois operandos em registradores, para que possamos promover o operando cujo tipo é menor.

Agora, porém, temos um problema referente à plataforma utilizada. No processador 80x86 só podemos usar as instruções "CBW" e "CWD" no registrador primário, ou seja AL e AX respectivamente. Isto requer uma solução um pouco complicada.

Você pode não gostar muito da minha solução, mas ela consiste no seguinte:

- Assuma que o registrador AL, AX ou DX:AX possui o SEGUNDO operando
- Assuma que o registrador BL, BX ou CX:BX possui o PRIMEIRO operando
- Se for necessário promover o PRIMEIRO, trocamos os valores entre os registradores (de acordo com o tipo), para deixar em AL ou AX o operando a ser promovido.
- Se for necessário promover algum operando, então convertemos AL ou AX (que já está com o operando correto).
- Se não ocorreu a troca antes, troque agora, para manter os operandos em uma ordem consistente.

O processo é difícil de explicar mas fácil de implementar, está longe de ser o mais eficiente possível mas serve para os nossos propósitos. Além disso, após o processo, os registradores SEMPRE vão ter esta configuração:

- O registrador AL, AX ou DX:AX terá o valor do PRIMEIRO operando
- O registrador BL, BX ou CX:BX terá o valor do SEGUNDO operando

Desta forma teremos sempre os registradores na ordem esperada para a subtração e a divisão. Uma deficiência do código é que faremos uma troca desnecessária no caso da adição e multiplicação, mas isto é fácil de corrigir; fica como exercício. Vamos começar com a rotina que faz a troca:

/* gera código para trocar registradores primário e secundário */
void asm_swap(char type)
{
	switch (type) {
	  case 'b':
	  	printf("\txchg al, bl\n");
	  	break;
	  case 'w':
	  	printf("\txchg ax, bx\n");
	  	break;
	  case 'l':
	  	printf("\txchg ax, bx\n");
	  	printf("\txchg dx, cx\n");
	  	break;
	}
}

Em seguida temos a rotina que faz a promoção em si, forçando os dois tipos a serem iguais:

/* faz a promoção dos tipos dos operandos e inverte a ordem dos mesmos */
char asm_sametype(char t1, char t2)
{
	int swaped = 0;
	int type = t1;
	
	if (t1 != t2) {
		if ((t1 == 'b') || (t1 == 'w' && t2 == 'l')) {
			type = t2;
			asm_swap(type);
			asm_convert(t1, t2);
			swaped = 1;
		} else {
			type = t1;
			asm_convert(t2, t1);
		}
	}
	if (!swaped)
		asm_swap(type);
		
	return type;
}

(Esta rotina não gera código diretamente, mas está intimamente ligada com a geração do código já que ela é dependente da arquitetura.)

"t1" deve ser o tipo do primeiro operando e "t2" o do segundo. Esta rotina verifica se os dois tipos são diferentes (um deles deve ser promovido). Se sim, verificamos se é o primeiro operando que deve ser promovido (caso em que fazemos a troca antes) ou o segundo (caso em que a troca deve ser feita depois).

Com estas rotinas em mãos, temos toda a munição necessária para incluir "asm_popadd" e "asm_popsub":

/* soma valor na pilha com valor no reg. primário */
char asm_popadd(char t1, char t2)
{
        char type;

        asm_pop(t1);
        type = asm_sametype(t1, t2);
        switch (type) {
          case 'b':
                printf("\tadd al, bl\n");
                break;
          case 'w':
                printf("\tadd ax, bx\n");
                break;
          case 'l':
                printf("\tadd ax, bx\n");
                printf("\tadc dx, cx\n");
                break;
        }

        return type;
}

/* subtrai do valor da pilha o valor no reg. primário */
char asm_popsub(char t1, char t2)
{
        char type;

        asm_pop(t1);
        type = asm_sametype(t1, t2);
        switch (type) {
          case 'b':
                printf("\tsub al, bl\n");
                break;
          case 'w':
                printf("\tsub ax, bx\n");
                break;
          case 'l':
                printf("\tsub ax, bx\n");
                printf("\tsbb dx, cx\n");
                break;
        }

        return type;
}

Depois de tudo pronto, os resultados finais são quase anti-climáticos. A lógica destas rotinas é bem simples. Tudo o que elas fazem é remover o resultado da pilha no registrador secundário, forçar os dois operadores para o mesmo tipo, e então gerar o código para o cálculo.

Repare que o código que faz a soma e a subtração depende dos tipos dos operandos. A nova versão da subtração não requer que invertamos o sinal em seguida. Isto porque os operandos já estão na ordem correta (o que é um efeito colateral de "sametype"). Esta inversão de ordem é boa para a subtração e divisão, mas não é necessária na soma e subtração, pois a ordem não faz diferença nestes casos e há uma instrução de troca desnecessária. Podemos passar um parâmetro a mais para "asm_sametype" dizendo se a ordem dos operandos importa ou não:

/* faz a promoção dos tipos dos operandos e inverte a ordem dos mesmos se necessário */
char asm_sametype(char t1, char t2, int ord_matters)
{
	int swaped = 0;
	int type = t1;
	
	if (t1 != t2) {
		if ((t1 == 'b') || (t1 == 'w' && t2 == 'l')) {
			type = t2;
			asm_swap(type);
			asm_convert(t1, t2);
			swaped = 1;
		} else {
			type = t1;
			asm_convert(t2, t1);
		}
	}
	if (!swaped && ord_matters)
		asm_swap(type);
		
	return type;
}

Certo, eu concordo que eu lhes mostrei muitas rotinas desde a última vez que testamos o código. Mas você deve admitir que cada nova rotina é simples e transparente, mesmo com as limitações da extensão de sinal e tudo mais. Se você (como eu) não gosta de testar tantas rotinas de uma só vez, tudo bem. É possível criar versões vazias de "asm_convert", e "asm_sametype", já que elas não processam a entrada. Você não vai obter o código correto, é claro, mas as coisas devem funcionar. Então, adicione as rotinas uma de cada vez.

Quando estiver testando o programa, não esqueça de declarar algumas variáveis antes, e então começar o "corpo" do programa com um "B" maiúsculo (para BEGIN). Você deve reparar que o analisador vai tratar de qualquer expressão aditiva. Uma vez que as rotinas de conversão estejam no lugar, você vai ver que código correto está sendo gerado, com conversões de tipo inseridas quando necessárias. Tente misturar variáveis de tipos diferentes, e também literais. Certifique-se de que tudo está funcionando apropriadamente. Como de costume, é uma boa idéia verificar se expressões inválidas são tratadas apropriadamente pelo compilador.

Por Que Tantas Rotinas?
-----------------------

Neste ponto, você deve achar que eu já atingi o ponto mais profundo em termos de chamadas de rotina aninhadas. Eu admito que há muito overhead aqui. Mas há um método na minha loucura. Como no caso de "unop", estou prestando atenção ao momento em que vamos querer uma melhor geração de código. Da forma como o código está organizado, podemos fazer isto sem modificações grandes ao programa.

Expressões com Multiplicação
----------------------------

Os procedimento para operações de multiplicação e divisão são quase os mesmos. De fato, no primeiro nível, eles são quase idênticos, então eu vou simplesmente mostrá-los aqui sem muito demora. O primeiro é nossa forma geral para "factor", que inclui expressões entre parênteses:

/* analisa e traduz um fator matemático */
char factor()
{
	char type;
	
	if (look == '(') {
		match('(');
		type = expression();
		match(')');
	} else if (isalpha(look))
		type = loadvar(getname());
	else
		type = loadnum(getnum());

	return type;
}

/* reconhece e traduz uma multiplicação */
char multiply(char type)
{
	match('*');
	return asm_popmul(type, factor());
}

/* reconhece e traduz uma multiplicação */
char divide(char type)
{
	match('/');
	return asm_popdiv(type, factor());
}

/* analisa e traduz um termo matemático */
char term()
{
	char type;
	
	type = factor();
	while (ismulop(look)) {
		asm_push(type);
		switch (look) {
		  case '*':
		  	type = multiply(type);
		  	break;
		  case '/':
		  	type = divide(type);
		  	break;
		}
	}
	
	return type;
}

Estas rotinas combinam quase que exatamente com as aditivas. Como antes, a complexidade é encapsulada dentro de "asm_popmul" e "asm_popdiv". Se você quiser testar o programa antes de chegarmos lá, você pode criar versões "fantasma" para elas, similar ao que foi feito com "asm_popadd" e "asm_popsub". Novamente, o código não vai estar correto neste ponto, mas o analisador deve ser capaz de tratar de expressões de complexidade arbitrária.

Multiplicação
-------------

Uma vez que você tenha se convencido de que o analisador em si está funcionando apropriadamente, precisamos descobrir o que devemos fazer para gerar o código correto. É aí que as coisas começam a ficar difíceis, pois as regras são mais complexas.

Vamos tratar do caso da multiplicação primeiro. Esta operação é parecida com as de soma já que os operandos devem ser do mesmo tamanho. Ela é diferente em dois aspectos importantes:

- O tipo do produto não é o mesmo dos operandos. Para o produto de dois "words", temos um resultado "long".

- O 80x86 não suporta multiplicação de dois operandos de 32-bits (não para o nosso caso, em que estamos tratando de registradores de 16-bits), portanto uma chamada a uma rotina externa é necessária. Esta rotina se tornará parte de nossa biblioteca.

NOTA: É possível multiplicar números de 32-bits usando os registradores extendidos de 32-bits usando as próprias instruções de máquina. Mas prefiro me manter com os 16-bits, pois o importante é aprender a técnica, que pode ser aplicada em outros casos. Multiplicação de 64-bits por exemplo.

As ações a serem tomadas podem ser melhor traduzidas na tabela:

  T1 -->  |                 |                 |                 |
          |                 |                 |                 |
      |   |        B        |        W        |       L         |
  T2  V   |                 |                 |                 |
-----------------------------------------------------------------
          |                 |                 |                 |
          |                 | Promover T2->w  | Promover T2->L  |
     B    | IMUL BL         | IMUL BX         | CALL MUL32      |
          | Resultado = W   | Resultado = L   | Resultado = L   |
          |                 |                 |                 |
-----------------------------------------------------------------
          |                 |                 |                 |
          | Promover T1->W  |                 | Promover T2->L  |
     W    | IMUL BX         | IMUL BX         | CALL MUL32      |
          | Resultado = L   | Resultado = L   | Resultado = L   |
          |                 |                 |                 |
-----------------------------------------------------------------
          |                 |                 |                 |
          | Promover T1->L  | Promover T1->L  |                 |
     L    | CALL MUL32      | CALL MUL32      | CALL MUL32      |
          | Resultado = L   | Resultado = L   | Resultado = L   |
          |                 |                 |                 |
-----------------------------------------------------------------

Esta tabela mostra as ações a serem tomadas para cada combinação de tipos de operandos. Há três coisas a notar: Primeiro, assumimos uma que temos uma rotina biblioteca MUL32 que faz multiplicações de 32 x 32 bits, com um produto de 32-bits (não 64-bits)! Se houve qualquer "overflow" no processo, nós ignoramos e retornamos apenas os 32 bits inferiores.

Segundo, repare que a tabela é simétrica... os dois operandos entram da mesma forma. FInalmente, repare que o produto é SEMPRE um "long", exceto quando ambos operandos são "byte"s. (Vale a pena notar, que muitas expressões vão acabar sendo do tipo "long", queiramos ou não. Talvez nossa idéia de simplesmente promover todos os tipos para "long" não fosse tão ruim assim, no fim das contas!)

Agora, claramente, vamos gerar código diferente para as multiplicações de 8, 16 e 32 bits.

/* multiplica valor na pilha com valor no reg. primário */
char asm_popmul(char t1, char t2)
{
        char type, multype;

	asm_pop(t1);
        type = asm_sametype(t1, t2, 0);
  	multype = 'l';
	switch (type) {
	  case 'b':
	  	printf("\tmul bl\n");
	  	multype = 'w';
	  	break;
	  case 'w':
	  	printf("\tmul bx\n");
	  	break;
	  case 'l':
	  	printf("\tcall MUL32\n");
	  	break;
	}

        return multype;
}

Como você pode ver a rotina começa da mesma forma que "asm_popadd". Os dois argumentos são forçados para o mesmo tipo. Finalmente o código é gerado para efetuar a multiplicação. Repare que o tipo de retorno é diferente dos operandos. Não é muito complicado, realmente.

Neste ponto, eu sugiro que você vá em frente e teste o programa. Tente todas as combinações de tamanho que você conseguir imaginar.

Divisão
-------

O caso da divisão não é tão simétrico. Eu também tenho algumas más notícias pra você.

Toda CPU moderna de 16-bits suporta divisão de inteiros. A especificação do fabricante descreve esta operação como sendo uma divisão de 32 por 16-bits, ou seja, você pode ter um dividendo de 32-bits dividido por um divisor de 16-bits. Aqui vai a má notícia:

	ELES ESTÃO MENTINDO PRA VOCÊ!!!
	
Se você não acredita, tente dividir qualquer número de 32-bits de tamanho (ou seja, que tenha bits diferentes de zero nos 16-bits mais significativos) pelo valor inteiro 1. Você vai se deparar com um erro de estouro de divisão.

O problema é que a instrução realmente requer que o quociente resultante caiba num resultado de 16-bits. Isto não vai acontecer A MENOS que o divisor seja grande o suficiente. Quando um número qualquer é dividido por uma unidade, o quociente é claro será o mesmo que o dividendo, que DEVE caber nos 16-bits do resultado.

Desde o princípio dos tempos (bem, dos computadores pelo menos), os criadores de CPUs tem provido este pequeno detalhe nos circuitos de divisão. Ele provê uma certa simetria nas coisas, já que é o modo inverso de como a multiplicação funciona. Mas já que "um" é um divisor perfeitamente válido (e comum), a divisão, conforme implementada em hardware, requer alguma ajuda dos programadores.

As implicações são:

- O tipo do quociente deve ser sempre o mesmo do dividendo. É independente do divisor.

- Apesar da CPU suportar um dividendo do tipo "long", as instruções providadas pelo hardware só são confiáveis para divisão de dividentos tipo "byte" e "word". Para dividentos do tipo "long", precisamos de outra rotina de biblioteca capaz de retornar um resultado "long".



Parece que vamos precisar de outra tabela, para resumir as ações necessárias:

  T1 -->  |                 |                 |                 |
          |                 |                 |                 |
      |   |        B        |        W        |       L         |
  T2  V   |                 |                 |                 |
-----------------------------------------------------------------
          |                 |                 |                 |
          | Converter T1->W |                 | Converter T2->L |
     B    | IDIV BL         | IDIV BL         | CALL DIV32      |
          | Resultado = B   | Resultado = W   | Resultado = L   |
          |                 |                 |                 |
-----------------------------------------------------------------
          |                 |                 |                 |
          | Converter T1->L | Converter T1->L | Converter T2->L |
     W    | IDIV BX         | IDIV BX         | CALL DIV32      |
          | Resultado = B   | Resultado = W   | Resultado = L   |
          |                 |                 |                 |
-----------------------------------------------------------------
          |                 |                 |                 |
          | Converter T1->L | Converter T1->L |                 |
     L    | CALL DIV32      | CALL DIV32      | CALL DIV32      |
          | Resultado = B   | Resultado = W   | Resultado = L   |
          |                 |                 |                 |
-----------------------------------------------------------------

(Você pode se perguntar porque é necessário fazer uma divisão de 32-bits, quando o dividendo é, digamos um simples valor "byte". Já que o número de bits no resultado só pode no máximo o número de bits do dividendo, por que se importar? A razão é que, se o divisor for um "long", e houver algum bit diferente de zero na parte mais significativa, o resultado da divisão deve ser zero. Podemos não conseguir isto se apenas a parte mais baixa do divisor for usada.)

O código a seguir provê o funcionamento correto para "asm_popdiv":

/* divide valor na pilha por valor do reg. primário */
char asm_popdiv(char t1, char t2)
{
        asm_pop(t1);

        /* se dividendo for 32-bits divisor deve ser também */
        if (t1 == 'l')
                asm_convert(t2, 'l');

        /* coloca operandos na ordem certa conforme o tipo */
        if (t1 == 'l' || t2 == 'l')
                asm_swap('l');
        else if (t1 == 'w' || t2 == 'w')
                asm_swap('w');
        else
                asm_swap('b');

        /* dividendo _REAL_ sempre será LONG...
           mas WORD se divisor for BYTE */
        if (t2 == 'b')
                asm_convert(t1, 'w');
        else
                asm_convert(t1, 'l');

        /* se um dos operandos for LONG, divisão de 32-bits */
        if (t1 == 'l' || t2 == 'l')
                printf("\tcall DIV32\n");
        else if (t2 == 'w') /* 32 / 16 */
                printf("\tidiv bx\n");
        else if (t2 == 'b') /* 16 / 8 */
                printf("\tidiv bl\n");

        /* tipo do quociente é sempre igual ao do dividendo */
        return t1;
}

Note que assumimos que DIV32 deixa o resultado ("long") em DX:AX.

Instale este novo procedimento para divisão. Neste ponto você deve estar apto a gerar código para qualquer tipo de expressão aritmética. Teste o programa a vontade!

Começando a se aprofundar
-------------------------

Finalmente, neste capítulo, aprendemos como tratar de variáveis (e literais) de tipos diferentes. Como você pode ver, não foi tão difícil. De certa forma, boa parte do código parece até mais simples do que em programas anteriores. Apenas os operadores de multiplicação e divisão nos exigiram um pouco mais de planejamento.

O conceito que tornou as coisas simples foi o de conversão de procedimentos como "expression" em funções que retornam o tipo do resultado. Uma vez estando isto feito, fomos capazes de reter a mesma estrutura geral do compilador.

Não vou fingir que nós cobrimos todos os aspectos do problema. Eu ignorei por completo aritmética sem sinal. Do que já foi visto, eu acho que você consegue ver que incluir isto não adiciona desafios novos, apenas novas possibilidades a serem testadas.

Eu também ignorei operadores lógicos como AND, OR, etc. Acontece que estes são muito fáceis de tratar. Todos os operadores lógicos são operações bit-a-bit, então eles são simétricos e portanto funcionam da mesma forma que "asm_popadd". Há uma diferença, porém: se for necessário extender o tamanho de uma variável lógica, a extensão deve ser feita como um número SEM SINAL. Números de ponto flutuante, também não são muito difíceis de lidar... apenas algumas novas funções na biblioteca, ou talvez instruções para o co-processador matemático.

Talvez mais importante que isso, eu também ignorei o problema de CHECAGEM de tipos, ao invés de conversão. Em outras palavras, nós permitimos operações entre variáveis de todas as combinações de tipos. Em geral isto não será sempre válido... certamente você não desejaria adicionar um inteiro a uma string por exemplo. Muitas linguagens também não permitem misturar variáveis tipo caracter e variáveis numéricas.

Novamente, não há nenhum grande problema a ser tratado neste caso. Já estamos verificando os tipos dos dois operandos... a maior parte da verificação é feita em procedimentos como "sametype". É muito fácil incluir uma chamada a um tratador de erros, se os tipos dos operandos forem incompatíveis.

No caso geral, podemos pensar em cada operador sendo tratado por um procedimento diferente, dependendo do tipo dos dois operandos. Isto é simples, porém tedioso, de implementar criando uma simples tabela de desvio com os tipos de operando como índices. Em Pascal, a operação equivalente pode ser conseguida com comandos "case" aninhados. Algumas das rotinas chamadas poderiam ser simplesmente rotinas de erro, enquanto outras podem fazer qualquer tipo de conversão necessária. Conforme novos tipos são adicionados, o número de procedimentos cresce numa escala de N ao quadrado, mas talvez não chegue a ser um número extraordinário de procedimentos.

O que fizemos aqui foi compactar tal tabela de desvios em poucas rotinas, simplesmente fazendo uso de simetra e outras regras de simplificação.

Coagir ou não coagir?
---------------------

Caso você não tenha entendido a mensagem ainda, certamente aparenta que TINY e KISS provavelmente NÃO serão linguagens fortemente tipadas, já que eu permiti mixagem e conversão automática de todos os tipos. O que nos leva à próxima questão:

	É realmente isto que queremos fazer?
	
A resposta vai depender do tipo de linguagem desejada, e da forma como você espera que ela se comporte. O que nós não tratamos é a questão de permitir ou negar o uso de operações envolvendo tipos diferentes. Em outras palavras, qual deve ser a SEMÂNTICA do nosso compilador? Nós desejamos conversão de tipos automática para todos os casos, para alguns casos, ou simplesmente não queremos qualquer tipo de conversão automática?

Vamos parar e pensar a respeito mais um pouco. Para isto, vamos rever um pouco da história.

FORTRAN II suportava apenas dois tipos de dados simples: números inteiros e reais. Era feita conversão implícita entre os tipos real e inteiro durante atribuições, mas não no meio de uma expressão. Todos os itens de dados (incluindo constantes literais) do lado direito de uma atribuição deveriam ser do mesmo tipo. Isto tornou as coisas bem fáceis... bem mais simples do que o que fizemos aqui.

Isto foi mudado em FORTRAN IV para suportar aritmética "de tipos misturados". Se uma expressão possuísse algum item real, todos os ítens seriam convertidos para reais e a expressão em si seria real. Para completar a figura, funções foram providas para converter explícitamente um tipo em outro, para forçar uma expressão a ter um tipo ou outro.

Isto levou a duas coisas: código que era mais fácil de escrever, e código que era menos eficiente. Isto porque programadores descuidados escreveriam expressões com constantes simples como 0 e 1, as quais seriam compiladas para que fosse feita desnecessariamente a conversão em tempo de execução. Ainda assim, o sistema funcionava bem, o que tende a indicar que conversão implícita de tipos é algo positivo.

C também é uma linguagem com tipagem fraca, embora suporte um número maior de tipos. Um compilador C não reclamaria se você adicionasse um caracter a um inteiro, por exemplo. Parcialmente, isto ocorre graças à convenção de C de promover todo caracter a um inteiro quando carregado, ou passado para uma lista de parâmetros. Isto simplifica bastante a conversão. De fato, em compiladores de sub-conjuntos de C que não suportam tipos "long" ou "float", acabamos no mesmo estágio em que nos encontrávamos anteriormente, em nossa primeira abordagem simplificada: toda variável possuía a mesma representação, quando carregada em um registrador. Isto torna a vida muito fácil!

O máximo da conversão automática de tipos em uma linguagem está em PL/I. Esta linguagem suporta um grande número de tipos de dados, e você pode misturá-los livremente. Se a conversão implícita de FORTRAN parecia boa, então as de PL/I deveriam ser como o Paraíso, mas elas acabaram parecendo mais com o Inferno! O problema é que com tantos tipos de dados, deveria haver um volume grande de conversões de tipos, E um volume correspondente de regras a respeito de como os operandos misturados deveriam ser convertidos. Estas regras tornaram-se tão complexas que ninguém mais conseguia se lembrar como elas eram! Muitos erros em programas PL/I tinham a ver com conversões inesperadas ou indesejadas. Às vezes uma coisa Positiva em excesso pode ser prejudicial!

Pascal, em oposição, é uma linguagem "fortemente tipada", o que significa ue em geral você não pode misturar tipos, mesmo que eles sejam diferentes apenas no NOME, e tenham a mesma representação básica! Niklaus Wirth fez de Pascal uma linguagem com tipos bem definidos para ajudar os programadores a se manterem longe de problemas, e estas restrições de fato salvaram muitos programadores deles mesmos, pois o compilador evitava que fizessem algo incorreto. É melhor encontrar o erro durante a compilação do que na fase de depuração. As mesmas restrições podem também causar frustração quando você REALMENTE quer misturar tipos, e isto tente a jogar ex-programadores C contra a parede.

Mesmo assim, Pascal permite algumas conversões implícitas. É possível atribuir um inteiro a um valor real. É possível também misturar os tipos inteiro e real em expressões do tipo Real. Os inteiros seriam automáticamente forçados para o tipo real, da mesma forma que em FORTRAN (e com o mesmo custo em tempo de execução escondido).

Você não pode, no entanto, converter da outra forma, de real para inteiro, sem aplicar a função de conversão explícita, "Trunc". A teoria aqui é, já que o valor numérico de um número real necessariamente pode ser alterado pela conversão (a parte fracionária será perdida), você realmente não deve fazê-lo em "segredo".

No espírito de tipagem forte, Pascal não permite que sejam misturadas variáveis do tipo caracter e inteira, sem aplicar as funções explícitas de conversão "Chr" e "Ord".

Turbo Pascal também inclui os tipos Byte, Word, e LongInt. Os dois primeiros são basicamente a mesma coisa que inteiros sem sinal. Em Turbo Pascal, eles podem ser livremente misturados com variáveis do tipo inteiro, e o compilador trata da conversão automaticamente. Porém, há checagens em tempo de execução, para evitar estouro dos valores ou respostas erradas. Repare que ainda assim não é possível misturar os tipos "Byte" e "Char", mesmo sendo eles armazenadas internamente na mesma representação.

O extremo em termos de linguagem fortemente tipada é Ada, que não permite NENHUMA conversão implícita, e também não permite aritmética misturada. A posição de Jean Ichbiah é que as conversões custam tempo de execução, e você não deveria poder adicionar este custo sem estar consciente disto. Forçar o programador a solicitar a conversão de tipos explícitamente, faz com que ele perceba que há um custo envolvido.

Eu fiz uso de outra linguagem fortemente tipada, uma pequena linguagem chamada Whimsical, criada por John Spray. Apesar de Whimsical ser uma linguagem voltada para programação de sistemas, ela requer conversão explícita SEMPRE. Nunca é feita uma conversão automática, mesmo aquelas suportadas por Pascal.

Esta abordagem possui certas vantagens: o compilador nunca precisa adivinhar o que fazer: o programador sempre deve dizer precisamente o que ele quer. Como resultado, a tendência é que exista uma correspondência de um-para-um entre o código-fonte e o código-objeto, e o compilador de John produzia código muito robusto.

Por outro lado, eu acho que as conversões explícitas podem ser dolorosas. Se eu quero, por exemplo, adicioner 1 a um caracter, ou aplicar uma operação "AND" com uma máscara, há uma série de conversões a serem feitas. Se eu fizer algo de errado, a única mensagem de erro é "Tipos não são compatíveis". Acontece que, a implementação de John da linguagem em seu compilador não diz exatamente quais tipos não são compatíveis... apenas diz em que LINHA o erro ocorreu.

Eu devo admitir que a maioria dos meus erros com este compilador são erros deste tipo, e eu perdi muito tempo com o compilador de Whimsical, tentando descobrir ONDE eu estava cometendo a ofensa. A única maneira de arrumar o erro é continuar tentando alguma coisa até que alguma coisa funcione.

Então o que devemos fazer em TINY e KISS? Para o primeiro, eu tenho a resposta: TINY vai suportar apenas os tipos caracter e inteiro, e nós vamos usar o truque de C para promover caracteres a inteiros internamente. Isto significa que o compilador TINY será MUITO mais simples do que o que já fizemos. A conversão de tipos em expressões é muito simples, já que nenhuma conversão será necessária! Já que o tipo longo não será suportado, também não vamos precisar das rotinas MUL32 e DIV32, nem a lógica para descobrir quando chamá-las. Eu GOSTO disto!

KISS, por outro lado, vai suportar o tipo longo.

Deve suportar aritmética com e sem sinal? Por razões de simplicidade eu preferiria que não. Isto adiciona uma certa complexidade à conversão de tipos. Mesmo Niklaus Wirth eliminal os tipos sem sinal (Cardinais) de sua nova linguagem Oberom, com o argumento que inteiros de 32-bits devem ser grandes o suficiente para todos.

Mas KISS supostamente é uma linguagem de programação de sistemas, o que significa que deveríamos poder fazer qualquer operação que pode ser feita em assembly. Já que o processador 80x86 suporta os dois tipos de operações com inteiro, eu acho que KISS também deve. Já vimos que operações lógicas devem ser extendidadas como inteiros sem sinal, portanto as conversões sem sinal são necessárias de qualquer forma.

Conclusão
---------

Isto encerra nossa seção sobre conversão de tipos. Sinto muito por ter feito você esperar tanto por ela, mas eu acho que você sente que valeu a pena.

Nos próximos capítulos, pretendo extender os tipos simples e incluir matrizes e ponteiros, e dar uma olhada sobre o que fazer a respeito de strings de caracteres. Isto deve acrescentar muito ao núcleo desta série. Depois disto, vou lhes apresentar as novas versões dos compiladores de TINY e KISS, e então vamos tratar de questões de otimização.

Até lá!

Copyright (C) 1990 Jack W. Crenshaw. Todos os direitos reservados.
Tradução e adaptação: Felipo Soranz (06/06/2002)
