VAMOS CONSTRUIR UM COMPILADOR!
por Jack W. Crenshaw, Ph.D. (03/06/1989)

Copyright (C) 1989 Jack W. Crenshaw. Todos os direitos reservados.
Tradução e adaptação: Felipo Soranz (25/05/2002)

Parte 11: Análise Léxica Revista
--------------------------------

Eu tenho algumas notícias boas e ruins. A ruim é que este capítulo não vai ser a respeito do que eu havia prometido. E o que é pior, nem o próximo.

A boa notícia é também a razão para esta seção: eu descobri uma forma de simplificar e melhorar a parte da análise léxica do compilador. Deixe-me explicar.

Conceitos
---------

Se vocês se lembram, já andamos muito no tópico de analisadores sintáticos na Parte 7, e eu deixei vocês com um projeto para um analisador sintático distribuído que parecia tão simples quanto possível... mais do que a maioria dos que eu já vi. Nós usamos esta idéia na Parte 10. A estrutura resultante do compilador era simples, e fazia bem o trabalho.

Recentemente, porém, eu comecei a ter problemas, e este é o tipo de mensagem que diz que talvez você esteja fazendo algo errado.

Tudo começou quando eu tentei tratar do problema do ponto-e-vírgula (;). Muitas pessoas me perguntaram a respeito, e se KISS teria ou não ponto-e-vírgula para separar os comandos. A minha intenção era não usá-los, simplesmente porque eu não gosto deles, e como você já viu, é provado que eles não são necessários.

Mas eu sei que muitos de vocês, como eu, se acostumaram com eles, e portanto eu resolvi escrever um capítulo curto para mostrar como eles podem ser facilmente adicionados, se você os quer tanto.

Bem, acontece que começou a parecer que eles não eram tão fáceis de adicionar. Na verdade parecia bem difícil.

Eu acho que eu deveria ter percebido que algo estava errado, por causa do problema das quebras de linha. Nos últimos capítulos nós tratamos deste problema, e eu mostrei como tratar de quebras de linha com uma rotina chamada, apropriadamente, "newline". Em TINY Versão 1.0, eu espalhei chamadas a esta rotina em pontos estratégicos do código.

Mas parece que cada vez que eu trato do problema de quebras de linha, ele parece ser complicado, e o analisador resultante acaba ficando meio frágil... algo adicionado aqui ou ali e as coisas começavam a dar errado. Olhando novamente para o problema, eu percebi que havia uma mensagem ali que eu não estava prestando atenção.

Quando eu tentei adicionar ponto-e-vírgula sobre quebras-de-linha é que a coisa complicou. Eu acabei com uma solução complexa demais. Eu percebi que algo fundamental tinha que mudar.

Portanto, de certa forma, este capítulo vai nos fazer dar um passo para trás e rever o problema de análise léxica novamente. Peço desculpas por isto. Este é o preço pago por me observar fazer as coisas em "tempo real". Mas a nova versão é definitivamente uma melhoria, e vai ser bastante útil para o que vem em seguida.

Como eu disse, o analisador léxico usado na parte 10 era tão simples quanto possível. Mas tudo pode ser melhorado. O novo analisador é mais parecido com um analisador léxico clássico, e não é tão simples quanto antes. Mas a estrutura geral do compilador é até mais simples do que antes. Também é mais robusta, e fácil de aumentar e/ou modificar. Eu acho que vai valer a pena gastarmos um tempo nesta melhoria. Portanto neste capítulo eu vou mostrar a nova estrutura. Sem dúvida você vai gostar de saber que, apesar das mudanças afetarem diversas rotinas, elas não são muito profundas e portanto não vamos perder quase nada do que já foi feito.

Ironicamente, o novo analisador léxico é muito mais convencional do que o antigo, e é muito parecido com um analisador genérico que eu mostrei anteriormente na parte 7. Então eu comecei a tentar ser mais esperto, e a minha esperteza quase me atirou pra fora do caminho. Talvez um dia eu aprenda: Keep It Simple, Stupid! (Mantenha Simples, Estúpido!)

O Problema
----------

O problema começa a se apresentar na rotina "block", que eu reproduzi abaixo:

/* analiza e traduz um bloco de comandos */
void block()
{
	int follow = 0;

	do {
		scan();
		switch (token) {
		  case 'i':
		  	doif();
		  	break;
		  case 'w':
		  	dowhile();
		  	break;
		  case 'R':
		  	doread();
		  	break;
		  case 'W':
		  	dowrite();
		  	break;
		  case 'e':
		  case 'l':
		  	follow = 1;
		  	break;
		  default:
		  	assignment();
		  	break;
		}
	} while (!follow);
}

Como você pode ver, "block" é orientado a comandos individuais do programa. A cada passagem do laço, sabemos que estamos no início de um novo comando. Nós saímos do bloco quando encontramos um END ou um ELSE.

Mas suponha que um ponto-e-vírgula seja encontrado. A rotina, como ela está agora, não é capaz de tratar dele, pois a rotina "scan" espera, e só consegue aceitar, tokens que começam com uma letra.

Eu fiquei pensando por um tempo no problema e tentando arrumar alguma solução. Eu achei muitas abordagens possíveis, mas nenhuma era muito satisfatória. Eu finalmente descobri a razão.

Lembre-se que quando começamos com nosso analisador sintático de caracteres simples, adotamos uma convenção de que o caracter lookahead seria sempre pré-carregado. Isto é, teríamos o caracter que corresponde à nossa posição atual na entrada, carregado na variável global "look", de forma que poderíamos examiná-lo tantas vezes quanto necessário. A regra que adotamos era que CADA reconhecedor, tendo encontrado seu token alvo, avançaria "look" para o próximo caracter na entrada.

Esta convenção fixa e simples nos foi muito útil quando tínhamos tokens de um caracter, e ainda é. Faria sentido aplicar a mesma regra a tokens multi-caracter.

Mas quando chegamos em análise sintática, eu comecei a violar aquela regra simples. O analisador sintático da parte 10 de fato avançava para o próximo token se encontrasse um identificador ou palavra-chave, mas NÃO fazia isto se encontrasse um retorno de linha, um caracter de espaço, ou um operador.

Agora, este tipo de operação "misturada" nos causa sérios problemas na rotina "block", pois o fato da entrada ter avançado ou não depende do tipo de token encontrado. Se for uma palavra-chave ou o alvo de um comando de atribuição, o "cursor", conforme definido pelo conteúdo de "look", avança para o próximo token OU para o começo de um espaço em branco. Se, por outro lado, o token é um ponto-e-vírgula, ou se emitimos uma quebra de linha, o cursor NÃO avança.

É desnecessário dizer que podemos adicionar lógica necessária para nos manter na mesma linha. Mas é complicado, e faz o analisador todo ficar muito frágil.

Há um jeito muito melhor, que é adotar a mesma regra que funcionou tão bem antes, aplicar a TOKENS o mesmo que a caracteres simples. Em outras palavras, vamos pré-carregar os tokens da mesma forma que sempre fizemos com caracteres. Parece tão óbvio uma vez que você tenha pensado desta forma.

É interessante que, se fizermos as coisas desta forma, o problema que tivemos com retornos de linha desaparece. Podemos simplesmente tratá-los como caracteres de espaço, o que significa que o tratamento deles se torna trivial, e MUITO menos suscetível a erros do que a forma que tivemos de tratar anteriormente.

A Solução
---------

Vamos começar a arrumar o problema reintroduzindo as duas rotinas:

/* analisa e traduz um nome (identificador ou palavra-chave) */
void getname()
{
	int i;

	skipwhite();
	if (!isalpha(look))
		expected("Identifier or Keyword");
	for (i = 0; isalnum(look) && i < MAXTOKEN; i++) {
		value[i] = toupper(look);
		nextchar();
	}
	value[i] = '\0';
	token = 'x';
}

/* analisa e traduz um número inteiro */
void getnum()
{
	int i;

	skipwhite();
	if (!isdigit(look))
		expected("Number");
	for (i = 0; isdigit(look) && i < MAXTOKEN; i++) {
		value[i] = look;
		nextchar();
	}
	value[i] = '\0';
	token = '#';
}

Estes dois procedimentos são funcionalmente quase idênticos aos que eu mostrei na Parte 7. Cada um carrega o token corrente, tanto um identificador como um número, na string global "value". Eles também alteram "token" para o código apropriado. A entrada é deixada com o caracter "look" contendo o primeiro caracter que NÃO é parte do token.

Podemos fazer o mesmo para operadores, mesmo multi-caracter, com uma rotina como:

/* analisa e traduz um operador */
void getop()
{
	int i;
	
	token = look;
	for (i = 0; !isalnum(look) && !isspace(look) && i < MAXTOKEN; i++) {
		value[i] = look;
		nextchar();
	}
	value[i] = '\0';
}

Repare que "getop" retorna, como seu token codificado, o PRIMEIRO caracter do operador. Isto é importante, pois significa que podemos usar este caracter para orientar o analisador, ao invés do caracter lookahead.

Temos que juntar estas rotinas em uma rotina única que trata dos três casos. A rotina seguinte lê qualquer um dos três tipos e sempre deixa a entrada posicionada depois do token:

/* pega o próximo token de entrada */
void nexttoken()
{
	skipwhite();
	if (isalpha(look))
		getname();
	else if (isdigit(look))
		getnum();
	else
		getop();
}

(Repare que eu coloquei "skipwhite" ANTES das chamadas ao invés de depois. Isto significa que, em geral, a variável "look" NÃO vai conter um valor muito útil, e portanto NÃO devemos usá-la como um valor de teste na análise, como temos feito até aui. Está é a grande diferença em relação a nossa abordagem normal.)

Agora, lembre-se que antes eu estava cuidadosamente NÃO tratando a quebra de linha como um caracter de espaço. Isto porque, com "skipwhite" sendo chamado por último no analisador léxico, o encontro com o retorno de linha iria gerar mais um comando de leitura. Se estivéssemos na última linha do programa, não poderíamos sair até entrar com uma nova linha com no mínimos um caracter. É por isso que precisávamos da segunda rotina, "newline", para tratar das quebras de linha.

Mas agora, com a chamada a "skipwhite" no início, é exatamente o comportamento que queremos. O compilador deve saber que há outro token em seguida ou ele não vai chamar "next". Em outras palavras, se ele não encontrou o END final ainda, vamos insistir em ler mais dados até encontrar algo.

Isto significa que podemos simplificar muito o programa e os conceitos, tratando a quebra de linha como um caracter de espaço, e eliminando "newline". Apenas trocamos o teste em "whitespace":

/* pula caracteres em branco */
void skipwhite()
{
	while (isspace(look))
		nextchar();
}

Já testamos rotinas similares na Parte 7, mas você pode tentar estas novas. Adicione a uma cópia do "berço" estas rotinas e chame "nexttoken" com o seguinte programa:

int main()
{
	init();
	do {
		nexttoken();
		printf("Token: %c, Value: %s\n", token, value);
	} while (token != '.');
}

Compile e verifique que é possível separar um programa em uma série de tokens, e que é possível obter a codificação correta para cada token.

Isto QUASE funciona, mas não totalmente. Há dois problemas potenciais: Primeiro, em KISS/TINY quase todo operador é de um só caracter. As únicas exceções são os operadores >=, <= e <>. Parece uma vergonha tratar todo operador como strings e fazer comparação de strings, quando apenas uma comparação de caracter seria quase sempre suficiente. Segundo, e mais importante, a coisa não FUNCIONA quando dois operadores aparecem juntos, como em (a+b)*(c+d). Aqui a string depois de "b" seria interpretada como um único operador ")*(".

É possível resolver isto. Por exemplo, poderíamos dar a "getop" uma lista dos caracteres válidos, e poderíamos tratar parênteses como tipos de operadores diferentes dos outros. Mas a coisa começa a virar bagunça.

Felizmente, há uma forma melhor de resolver todos estes problemas. Como quase todo operador é de um único caracter, vamos simplesmente tratá-los desta forma, e permitir que "getop" pegue apenas um caracter no momento. Isto não só simplifica "getop", mas também acelera as coisas um pouco. Ainda temos o problema dos operadores relacionais, mas estamos tratando deles como casos especiais de qualquer maneira.

Aqui está a versão final de "getop":

/* analisa e traduz um operador */
void getop()
{
	skipwhite();
	token = look;
	value[0] = look;
	value[1] = '\0';
	nextchar();
}

Repare que eu ainda atribuo um valor a "value". Se você estiver muito preocupado com eficiência, é possível remover isto (embora vá fazer uma diferença muito pequena realmente). Quando esperamos um operador, vamos testar apenas "token" de qualquer maneira, então o valor não tem tanta importância. Mas para mim parece ser uma boa prática colocar algum valor lá, só por garantia.

Tente esta nova versão com algum código realístico. Deve ser possível separar qualquer programa em seus tokens individuais, com a diferença que operadores relacionais de dois caracteres serão reconhecidos como tokens separados. Mas tudo bem... vamos tratá-los desta forma.

Na parte 7 a função de "nexttoken" estava combinada com a rotina "scan", que também verificava cada identificador com uma lista de palavras-chave e codificava cada uma que fosse encontrada. Como eu havia mencionado no momento, a última coisa que gostaríamos de fazer é usar tal rotina em locais onde palavras-chave não deveriam aparecer, como em expressões. Se tivéssemos feito isto, a lista de palavras-chave seria comparada com cada identificador no código. Nada bom.

A maneira correta de tratar disto é simplesmente separar as funções de capturar tokens e procurar por palavras-chave. A versão de "scan" mostrada abaixo não faz NADA a não ser verificar palavras-chave. Repare que ela opera no token corrente e NÃO avança na entrada.

/* analisador léxico. analisa identificador ou palavra-chave */
void scan()
{
	int kw;

        if (token == 'x') {
                kw = lookup(value, kwlist, KWLIST_SZ);
        	if (kw >= 0)
        		token = kwcode[kw];
        }
}

Há um último detalhe. No compilador há alguns lugares onde temos que verificar o valor do token. Normalmente, isto é feito para diferenciar entre os diferentes ENDs, mas há mais alguns locais. (Eu devo lembrar que podemos sempre eliminar a necessidade de comparar caracteres END codificando cada um deles com um caracter diferente. Neste momento estamos definitivamente sendo preguiçosos.)

A seguinte versão de "matchstring" toma o lugar da versão caracter. Note que, como em "match", ela AVANÇA na entrada.

/* compara string com texto do token atual */
void matchstring(char *s)
{
	if (strcmp(value, s) != 0)
		expected(s);
	nexttoken();
}

Arrumando o Compilador
----------------------

Armados com estas novas rotinas de análise léxica, podemos começar a arrumar o compilador para usá-las apropriadamente. As mudanças são bem pequenas, mas há alguns lugares em que mais mudanças são necessárias. Ao invés de mostrar cada lugar, vou dar uma idéia geral e então mostrar o produto completo.

Em primeiro lugar, o código para a rotina "block" não muda, mas sua função sim:

/* analiza e traduz um bloco de comandos */
void block()
{
	int follow = 0;

	do {
		scan();
		switch (token) {
		  case 'i':
		  	doif();
		  	break;
		  case 'w':
		  	dowhile();
		  	break;
		  case 'R':
		  	doread();
		  	break;
		  case 'W':
		  	dowrite();
		  	break;
		  case 'e':
		  case 'l':
		  	follow = 1;
		  	break;
		  default:
		  	assignment();
		  	break;
		}
	} while (!follow);
}

Lembre-se que a nova versão de "scan" não avança na entrada, apenas procura por palavras-chave. A entrada deve ser avançada por cada rotina que "block" chama.

Em geral, temos que trocar todo teste em "look" por um similar em "token". Por exemplo:

/* analisa e traduz uma expressão booleana */
void boolexpression()
{
	boolterm();
	while (isorop(token)) {
		asm_push();
		switch (token) {
		  case '|':
		  	boolor();
		  	break;
		  case '~':
		  	boolxor();
		  	break;
		}
	}
}

Em rotinas como "add", não temos mais que usar "match". Só temos que chamar "nexttoken" para avançar na entrada:

/* reconhece e traduz uma adição */
void add()
{
	nexttoken();
	term();
	asm_popadd();
}

As estruturas de controle são na verdade mais simples. Simplesmente chamamos "nexttoken" para avançar nas palavras-chave de controle:

/* analiza e traduz um comando IF-ELSE-ENDIF */
void doif()
{
	int l1, l2;

	nexttoken();
	boolexpression();
	l1 = newlabel();
	l2 = l1;
	asm_jmpfalse(l1);
	block();
	if (token == 'l') {
		nexttoken();
		l2 = newlabel();
		asm_jmp(l2);
		printf("L%d:\n", l1);
		block();
	}
	printf("L%d:\n", l2);
	matchstring("ENDIF");
}

Esta é a extensão das mudanças NECESSÁRIAS. Na listagem de TINY Versão 1.1 abaixo, eu também fiz algumas outras "melhorias" que não são na verdade necessárias. Deixe-me explicá-las brevemente:

1) Removi as rotinas "prog" e "mainblock", e combinei suas funções no programa principal. Elas não pareciam estar ajudando na compreensão... na verdade parecia que elas estavam complicando as coisas um pouco.

2) Removi as palavras-chave PROGRAM e BEGIN da lista. Elas ocorrem apenas em um lugar, então não é necessário procurar por elas.

3) Tendo sido atacado por uma overdose de esperteza, eu me lembrei que TINY deveria ser um programa minimalista. Portanto, eu troquei o tratamento fantasioso do menos unário pelo mais simples que eu consegui. Um grande passo para trás na qualidade do código, mas uma grande simplificação do compilador. KISS é o lugar certo para usar a outra versão.

4) Adicionei algumas rotinas de checagem de erro como "checktable" e "checkdup", e troquei o código "em linha" por chamadas a elas. Isto faz uma limpeza em diversas rotinas.

5) Retirei a checagem de erro da rotinas de geração de código "store", e coloquei-a no analisador, que é o lugar em que ela deve estar. Veja "assignment", por exemplo.

6) Adicionei uma nova tabela ("symtype") para os tipos dos identificadores. Isto será útil para mais tarde. Eu poderia ter criado uma estrutura "symbol" e combinar o nome e o tipo na mesma estrutura. Mas teríamos que construir uma função "lookup" separada pra símbolos e outra para palavras-chave. Deixemos assim por enquanto.

7) A rotina "addsymbol" agora tem dois parâmetros, que faz com que as coisas fiquem mais modulares.

8) Repare na maneira que estou tratando operadores multi-caracter em "relation". É essencialmente a mesma. Apenas trocando "match" por "nexttoken" onde apropriado.

9) Corrigi o erro na rotina "doread"... a anterior não verificava se o nome da variável era válido.

10) Removi o tratamento dos inicializadores na declaração de variáveis, pois isto não acrescenta muito à linguagem, já que não há como usar expressões completas. Além disso estou tentando manter TINY simples por enquanto e isto iria complicar um pouco o código. Se você acha que isto é dar um passo atrás, sinta-se livre para manter o tratamento de constantes numéricas.

Conclusão
---------

O compilador resultante para TINY é dado abaixo. Fora a remoção da palavra-chave PROGRAM, ele compila a mesma linguagem que antes. Só está um pouco mais "limpo", e mais importante, está consideravelmente mais robusto. Eu me sinto bem com ele.

O próximo capítulo vai ser outro desvio do nosso rumo: a discussão sobre ponto-e-vírgula e outras coisas que me fizeram bagunçar as coisas anteriormente. ENTÃO partiremos para procedimentos e tipos. Contine comigo. A adição destas características vai ser uma grande melhoria fazendo com que KISS saia da categoria de "linguagem de brinquedo". Estamos chegando muito perto de estar aptos a escrever um compilador sério.

TINY Versão 1.1

/*
TINY Versão 1.1

O código abaixo foi escrito por Felipo Soranz e é uma adaptação
do código original em Pascal escrito por Jack W. Crenshaw em sua
série "Let's Build a Compiler".

Este código é de livre distribuição e uso.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SYMTBL_SZ 1000
#define KWLIST_SZ 9
#define MAXTOKEN 16

int lblcount; /* indica o rótulo atual */

/* tabela de símbolos */
char *symtbl[SYMTBL_SZ];
char symtype[SYMTBL_SZ];
int nsym; /* número de entradas atuais na tabela de símbolos */

/* códigos e lista de palavras-chave */
char kwcode[KWLIST_SZ+1] = "ileweRWve";
char *kwlist[KWLIST_SZ] = {"IF", "ELSE", "ENDIF", "WHILE", "ENDWHILE",
			   "READ", "WRITE", "VAR", "END"};

char look; /* O caracter lido "antecipadamente" (lookahead) */
char token; /* código do token atual */
char value[MAXTOKEN+1]; /* texto do token atual */

/* PROTÓTIPOS */

/* rotinas utilitárias */
void init();
void nextchar();
void error(char *s);
void fatal(char *s);
void expected(char *s);
void undefined(char *name);
void duplicated(char *name);
void checkident();

/* reconhecedores */
int isaddop(char c);
int ismulop(char c);
int isorop(char c);
int isrelop(char c);

/* tratamento de símbolos */
int lookup(char *s, char *list[], int size);
int locate(char *name);
int intable(char *name);
void checktable(char *name);
void addsymbol(char *name, char type);

/* analisador léxico */
void skipwhite();
void getname();
void getnum();
void getop();
void nexttoken();
void scan();
void matchstring(char *s);

/* rótulos */
int newlabel();

/* rotinas de geração de código */
void asm_clear();
void asm_negative();
void asm_loadconst(char *name);
void asm_loadvar(char *name);
void asm_push();
void asm_popadd();
void asm_popsub();
void asm_popmul();
void asm_popdiv();
void asm_store(char *name);
void asm_not();
void asm_popand();
void asm_popor();
void asm_popxor();
void asm_popcompare();
void asm_relop(char op);
void asm_jmp(int label);
void asm_jmpfalse(int label);
void asm_read();
void asm_write();
void header();
void prolog();
void epilog();
void allocvar(char *name, int value);

/* rotinas do analisador sintático */

/* expressões aritméticas */
void factor();
void multiply();
void divide();
void term();
void add();
void subtract();
void expression();

/* expressões booleanas e relações */
void relation();
void notfactor();
void boolterm();
void boolor();
void boolxor();
void boolexpression();

/* bloco, estruturas de controle e comandos */
void assignment();
void doif();
void dowhile();
void readvar();
void doread();
void writevar();
void dowrite();
void block();

/* declarações */
void decl();
void topdecls();

/* PROGRAMA PRINCIPAL */

int main()
{
	init();

	matchstring("PROGRAM");
	header();
	topdecls();
	matchstring("BEGIN");
	prolog();
	block();
	matchstring("END");
	epilog();

	return 0;
}

/* inicialização do compilador */
void init()
{
	nsym = 0;

	nextchar();
	nexttoken();
}

/* lê próximo caracter da entrada em lookahead */
void nextchar()
{
	look = getchar();
}

/* imprime mensagem de erro sem sair */
void error(char *s)
{
	fprintf(stderr, "Error: %s\n", s);
}

/* imprime mensagem de erro e sai */
void fatal(char *s)
{
	error(s);
	exit(1);
}

/* mensagem de erro para string esperada */
void expected(char *s)
{
	fprintf(stderr, "Error: \'%s\' expected\n", s);
	exit(1);
}

/* avisa a respeito de um identificador desconhecido */
void undefined(char *name)
{
	fprintf(stderr, "Error: Undefined identifier \'%s\'\n", name);
	exit(1);
}

/* avisa a respeito de um identificador desconhecido */
void duplicated(char *name)
{
	fprintf(stderr, "Error: Duplicated identifier \'%s\'\n", name);
	exit(1);
}

/* reporta um erro se token NÃO é identificador */
void checkident()
{
        if (token != 'x')
                expected("Identifier");
}

/* testa operadores de adição */
int isaddop(char c)
{
	return (c == '+' || c == '-');
}

/* testa operadores de multiplicação */
int ismulop(char c)
{
	return (c == '*' || c == '/');
}

/* testa operadores OU */
int isorop(char c)
{
	return (c == '|' || c == '~');
}

/* testa operadores relacionais */
int isrelop(char c)
{
	return (strchr("=#<>", c) != NULL);
}

/* pula caracteres em branco */
void skipwhite()
{
	while (isspace(look))
		nextchar();
}

/* procura por string em tabela,
   usado para procurar palavras-chave e símbolos */
int lookup(char *s, char *list[], int size)
{
	int i;

	for (i = 0; i < size; i++) {
		if (strcmp(list[i], s) == 0)
			return i;
	}

	return -1;
}

/* retorna o endereço do identificador na tabela de símbolos */
int locate(char *name)
{
        return lookup(name, symtbl, nsym);
}

/* verifica se "name" consta na tabela de símbolos */
int intable(char *name)
{
	if (lookup(name, symtbl, nsym) < 0)
		return 0;
	return 1;
}

/* reporta um erro se identificador NÃO constar na tabela de símbolos */
void checktable(char *name)
{
        if (!intable(name))
                undefined(name);
}

/* reporta um erro se identificador JÁ constar na tabela de símbolos */
void checkdup(char *name)
{
        if (intable(name))
                duplicated(name);
}

/* adiciona novo identificador à tabela de símbolos */
void addsymbol(char *name, char type)
{
	char *newsym;

        checkdup(name);

	if (nsym >= SYMTBL_SZ) {
		fatal("Symbol table full!");
	}

	newsym = (char *) malloc(sizeof(char) * (strlen(name) + 1));
	if (newsym == NULL)
		fatal("Out of memory!");

	strcpy(newsym, name);

	symtbl[nsym] = newsym;
        symtype[nsym] = type;
        nsym++;
}

/* analisa e traduz um nome (identificador ou palavra-chave) */
void getname()
{
	int i;

	skipwhite();
	if (!isalpha(look))
		expected("Identifier");
	for (i = 0; isalnum(look) && i < MAXTOKEN; i++) {
		value[i] = toupper(look);
		nextchar();
	}
	value[i] = '\0';
	token = 'x';
}

/* analisa e traduz um número inteiro */
void getnum()
{
	int i;

	skipwhite();
	if (!isdigit(look))
		expected("Number");
	for (i = 0; isdigit(look) && i < MAXTOKEN; i++) {
		value[i] = look;
		nextchar();
	}
	value[i] = '\0';
	token = '#';
}

/* analisa e traduz um operador */
void getop()
{
	skipwhite();
	token = look;
	value[0] = look;
	value[1] = '\0';
	nextchar();
}

/* pega o próximo token de entrada */
void nexttoken()
{
	skipwhite();
	if (isalpha(look))
		getname();
	else if (isdigit(look))
		getnum();
	else
		getop();
}

/* analisador léxico. analisa identificador ou palavra-chave */
void scan()
{
	int kw;

        if (token == 'x') {
                kw = lookup(value, kwlist, KWLIST_SZ);
        	if (kw >= 0)
        		token = kwcode[kw];
        }
}

/* compara string com texto do token atual */
void matchstring(char *s)
{
	if (strcmp(value, s) != 0)
		expected(s);
        nexttoken();
}

/* gera um novo rótulo */
int newlabel()
{
	return lblcount++;
}

/* ROTINAS DE GERAÇÃO DE CÓDIGO */

/* zera o registrador primário */
void asm_clear()
{
	printf("\txor ax, ax\n");
}

/* negativa o reg. primário */
void asm_negative()
{
	printf("\tneg ax\n");
}

/* carrega uma constante numérica no reg. prim. */
void asm_loadconst(char *val)
{
	printf("\tmov ax, %s\n", val);
}

/* carrega uma variável no reg. prim. */
void asm_loadvar(char *name)
{
	if (!intable(name))
		undefined(name);
	printf("\tmov ax, word ptr %s\n", name);
}

/* coloca reg. prim. na pilha */
void asm_push()
{
	printf("\tpush ax\n");
}

/* adiciona o topo da pilha ao reg. prim. */
void asm_popadd()
{
	printf("\tpop bx\n");
	printf("\tadd ax, bx\n");
}

/* subtrai o reg. prim. do topo da pilha */
void asm_popsub()
{
	printf("\tpop bx\n");
	printf("\tsub ax, bx\n");
	printf("\tneg ax\n");
}

/* multiplica o topo da pilha pelo reg. prim. */
void asm_popmul()
{
	printf("\tpop bx\n");
	printf("\tmul bx\n");
}

/* divide o topo da pilha pelo reg. prim. */
void asm_popdiv()
{
	printf("\tpop bx\n");
	printf("\txchg ax, bx\n");
	printf("\tcwd\n");
	printf("\tdiv bx\n");
}

/* armazena reg. prim. em variável */
void asm_store(char *name)
{
	printf("\tmov word ptr %s, ax\n", name);
}

/* inverte reg. prim. */
void asm_not()
{
	printf("\tnot ax\n");
}

/* "E" do topo da pilha com reg. prim. */
void asm_popand()
{
	printf("\tpop bx\n");
	printf("\tand ax, bx\n");
}

/* "OU" do topo da pilha com reg. prim. */
void asm_popor()
{
	printf("\tpop bx\n");
	printf("\tor ax, bx\n");
}

/* "OU-exclusivo" do topo da pilha com reg. prim. */
void asm_popxor()
{
	printf("\tpop bx\n");
	printf("\txor ax, bx\n");
}

/* compara topo da pilha com reg. prim. */
void asm_popcompare()
{
	printf("\tpop bx\n");
	printf("\tcmp bx, ax\n");
}

/* altera reg. primário (e flags, indiretamente) conforme a comparação */
void asm_relop(char op)
{
	char *jump;
	int l1, l2;

	l1 = newlabel();
	l2 = newlabel();

	switch (op) {
	  case '=': jump = "je"; break;
	  case '#': jump = "jne"; break;
	  case '<': jump = "jl"; break;
	  case '>': jump = "jg"; break;
	  case 'L': jump = "jle"; break;
	  case 'G': jump = "jge"; break;
	}

	printf("\t%s L%d\n", jump, l1);
	printf("\txor ax, ax\n");
	printf("\tjmp L%d\n", l2);
	printf("L%d:\n", l1);
	printf("\tmov ax, -1\n");
	printf("L%d:\n", l2);
}

/* desvio incondicional */
void asm_jmp(int label)
{
	printf("\tjmp L%d\n", label);
}

/* desvio se falso (0) */
void asm_jmpfalse(int label)
{
	printf("\tjz L%d\n", label);
}

/* lê um valor para o registrador primário e armazena em variável */
void asm_read()
{
	printf("\tcall READ\n");
	asm_store(value);
}

/* mostra valor do reg. primário */
void asm_write()
{
	printf("\tcall WRITE\n");
}

/* cabeçalho do código assembly */
void header()
{
	printf(".model small\n");
	printf(".stack\n");
	printf(".code\n");
	printf("extrn READ:near, WRITE:near\n");
	printf("PROG segment byte public\n");
	printf("\tassume cs:PROG,ds:PROG,es:PROG,ss:PROG\n");
}

/* prólogo da rotina principal */
void prolog()
{
	printf("MAIN:\n");
	printf("\tmov ax, PROG\n");
	printf("\tmov ds, ax\n");
	printf("\tmov es, ax\n");
}

/* epílogo da rotina principal */
void epilog()
{
	printf("\tmov ax,4C00h\n");
	printf("\tint 21h\n");
	printf("PROG ends\n");
	printf("\tend MAIN\n");
}

/* aloca memória para uma declaração de variável (+inicializador) */
void allocvar(char *name, int value)
{
	printf("%s:\tdw %d\n", name, value);
}

/* analisa e traduz um fator matemático */
void factor()
{
	if (token == '(') {
                nexttoken();
		boolexpression();
		matchstring(")");
	} else {
                if (token == 'x')
        		asm_loadvar(value);
        	else if (token == '#')
        		asm_loadconst(value);
        	else
        		expected("Math Factor");
                nexttoken();
        }
}

/* reconhece e traduz uma multiplicação */
void multiply()
{
        nexttoken();
	factor();
	asm_popmul();
}

/* reconhece e traduz uma divisão */
void divide()
{
        nexttoken();
	factor();
	asm_popdiv();
}

/* analisa e traduz um termo matemático */
void term()
{
        factor();
	while (ismulop(token))  {
		asm_push();
		switch (token) {
		  case '*':
			multiply();
			break;
		  case '/':
			divide();
			break;
		}
	}
}

/* reconhece e traduz uma adição */
void add()
{
        nexttoken();
	term();
	asm_popadd();
}

/* reconhece e traduz uma subtração*/
void subtract()
{
        nexttoken();
	term();
	asm_popsub();
}

/* analisa e traduz uma expressão matemática */
void expression()
{
        if (isaddop(token))
                asm_clear();
        else
                term();
	while (isaddop(token))  {
		asm_push();
		switch (token) {
		  case '+':
			add();
			break;
		  case '-':
			subtract();
			break;
		}
	}
}

/* analisa e traduz uma relação */
void relation()
{
	char op;

	expression();
	if (isrelop(token)) {
		op = token;
		nexttoken(); /* só para remover o operador do caminho */
		if (op == '<') {
			if (token == '>') { /* <> */
				nexttoken();
				op = '#';
			} else if (token == '=') {
				nexttoken();
				op = 'L';
			}
		} else if (op == '>' && token == '=') {
			nexttoken();
			op = 'G';
		}
		asm_push();
                expression();
                asm_popcompare();
		asm_relop(op);
	}
}

/* analisa e traduz um fator booleano com NOT inicial */
void notfactor()
{
	if (token == '!') {
		nexttoken();
		relation();
		asm_not();
	} else
		relation();
}

/* analisa e traduz um termo booleano */
void boolterm()
{
	notfactor();
	while (token == '&') {
		asm_push();
		nexttoken();
		notfactor();
		asm_popand();
	}
}

/* reconhece e traduz um "OR" */
void boolor()
{
	nexttoken();
	boolterm();
	asm_popor();
}

/* reconhece e traduz um "xor" */
void boolxor()
{
	nexttoken();
	boolterm();
	asm_popxor();
}

/* analisa e traduz uma expressão booleana */
void boolexpression()
{
	boolterm();
	while (isorop(token)) {
		asm_push();
		switch (token) {
		  case '|':
		  	boolor();
		  	break;
		  case '~':
		  	boolxor();
		  	break;
		}
	}
}

/* analisa e traduz um comando de atribuição */
void assignment()
{
	char name[MAXTOKEN+1];

	strcpy(name, value);
        checktable(name);
	nexttoken();
	matchstring("=");
	boolexpression();
	asm_store(name);
}

/* analiza e traduz um comando IF-ELSE-ENDIF */
void doif()
{
	int l1, l2;

	nexttoken();
	boolexpression();
	l1 = newlabel();
	l2 = l1;
	asm_jmpfalse(l1);
	block();
	if (token == 'l') {
		nexttoken();
		l2 = newlabel();
		asm_jmp(l2);
		printf("L%d:\n", l1);
		block();
	}
	printf("L%d:\n", l2);
	matchstring("ENDIF");
}

/* analiza e traduz um comando WHILE-ENDWHILE */
void dowhile()
{
	int l1, l2;

	nexttoken();
	l1 = newlabel();
	l2 = newlabel();
	printf("L%d:\n", l1);
	boolexpression();
	asm_jmpfalse(l2);
	block();
	matchstring("ENDWHILE");
	asm_jmp(l1);
	printf("L%d:\n", l2);
}

/* lê uma variável única */
void readvar()
{
        checkident();
        checktable(value);
        asm_read(value);
        nexttoken();
}

/* analiza e traduz um comando READ */
void doread()
{
        nexttoken();
	matchstring("(");
	for (;;) {
                readvar();
		if (token != ',')
			break;
                nexttoken();
	}
	matchstring(")");
}

/* analiza e traduz um comando WRITE */
void dowrite()
{
	nexttoken();
	matchstring("(");
	for (;;) {
		expression();
		asm_write();
		if (token != ',')
			break;
		nexttoken();
	}
	matchstring(")");
}

/* analiza e traduz um bloco de comandos */
void block()
{
	int follow = 0;

	do {
		scan();
		switch (token) {
		  case 'i':
		  	doif();
		  	break;
		  case 'w':
		  	dowhile();
		  	break;
		  case 'R':
		  	doread();
		  	break;
		  case 'W':
		  	dowrite();
		  	break;
		  case 'e':
		  case 'l':
		  	follow = 1;
		  	break;
		  default:
		  	assignment();
		  	break;
		}
	} while (!follow);
}

/* declaração de variáveis */
void decl()
{
        nexttoken();
        if (token != 'x')
                expected("Variable name");
        checkdup(value);
        addsymbol(value, 'v');
        allocvar(value, 0);
        nexttoken();
}

/* analisa e traduz declarações */
void topdecls()
{
	scan();
	while (token == 'v') {
                do {
                        decl();
                } while (token == ',');
	}
}

Copyright (C) 1989 Jack W. Crenshaw. Todos os direitos reservados.
Tradução e adaptação: Felipo Soranz (26/05/2002)
